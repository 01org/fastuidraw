/*!
 * \file fastuidraw_banded_rays.glsl.resource_string
 * \brief file fastuidraw_banded_rays.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@gmail.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@gmail.com>
 *
 */

/*!\addtogroup GLSLFragCode
 * @{
 */

///@cond

/* must have the macro/function
 *
 *  fastuidraw_fetch_glyph_data(X)
 *
 * that returns a single 32-bit uint value at index X of
 * a large array of 32-bit uint values storing the data
 *
 * and optionally define the macro/function
 *
 *  fastuidraw_fetch_glyph_data_fp16x2(X)
 *
 * the reads a single 32-bit uint value that is bit-casted
 * to a (fp16, fp16) pair realized as a vec2. For example
 * it can be defined as
 * unpackHalf2x16(fastuidraw_fetch_glyph_data(X))
 */

struct fastuidraw_banded_rays_band
{
  uint num_curves;
  uint curve_offset;
};

struct fastuidraw_banded_rays_curve
{
  vec2 p0, p1, p2;
};

struct fastuidraw_banded_rays_distance_type
{
  float distance_increment;
  float distance_decrement;
};

void
fastuidraw_banded_rays_init_distance(out fastuidraw_banded_rays_distance_type nv)
{
  /* Just initialize to some value that is large (strictly speaking
   * we only need a value greater than 0.5, but make it larger
   * for debug renders to be useful).
   */
  nv.distance_increment = nv.distance_decrement = 120.0;
}

void
fastuidraw_banded_rays_update_distance(in float dist, in bool is_increment,
                                       inout fastuidraw_banded_rays_distance_type nv)
{
  /* We are assuming that there are no cancelling curves in the glyph data.
   * The class GlyphRenderDataRestrictedRays has code to detect most forms
   * of cancelling curves (it detects partially overlapping vertical and
   * horizontal curves along with perfectly overlapping general curves).
   */
  if (is_increment)
    {
      nv.distance_increment = min(nv.distance_increment, dist);
    }
  else
    {
      nv.distance_decrement = min(nv.distance_decrement, dist);
    }
}

void
fastuidraw_banded_rays_load_band(in uint loc, out fastuidraw_banded_rays_band band)
{
  uint raw;

  raw = fastuidraw_fetch_glyph_data(loc);
  band.num_curves = FASTUIDRAW_EXTRACT_BITS(fastuidraw_banded_rays_numcurves_bit0,
                                            fastuidraw_banded_rays_numcurves_numbits,
                                            raw);
  band.curve_offset = FASTUIDRAW_EXTRACT_BITS(fastuidraw_banded_rays_curveoffset_bit0,
                                              fastuidraw_banded_rays_curveoffset_numbits,
                                              raw);
}

vec2
fastuidraw_banded_rays_load_point(in uint loc)
{
  return fastuidraw_fetch_glyph_data_fp16x2(loc);
}

void
fastuidraw_banded_rays_load_curve(in uint loc, out fastuidraw_banded_rays_curve curve)
{
  /* a reasonable shader compiler should re-order so that the reads of
   * the curve data come first followed by the assignment of values.
   */
  curve.p0 = fastuidraw_banded_rays_load_point(loc);
  curve.p1 = fastuidraw_banded_rays_load_point(loc + 1u);
  curve.p2 = fastuidraw_banded_rays_load_point(loc + 2u);
}

vec2
fastuidraw_banded_rays_intersect_y_equals_0(in fastuidraw_banded_rays_curve curve, out bool f1, out bool f2, out int isignA)
{
  const float tiny = 0.0001;
  float x1, x2, t1, t2;
  vec2 A, B, C;

  /* The curve is given by
   *  f(t) = (1-t)^2 p0 + 2t(t-1) p1 + t^2 p2
   *       = A t^2 - 2B t + C
   *
   * which gives
   *
   *  A = p0 - 2p1 + p2
   *  B = p0 - p1
   *  C = p0
   */
  A = curve.p0 - 2.0 * curve.p1 + curve.p2;
  B = curve.p0 - curve.p1;
  C = curve.p0;

  if (abs(A.y) > tiny)
    {
      float D, Ap, Bp, q1, q2, q3, signA;

      signA = sign(A.y);
      isignA = (A.y > 0.0) ? 1 : -1;
      q1 = signA * curve.p0.y;
      q2 = signA * curve.p1.y;
      q3 = signA * curve.p2.y;
      Ap = abs(A.y);
      Bp = signA * B.y;

      D = B.y * B.y - A.y * C.y;
      if (D > 0.0)
        {
          float rA;

          D = sqrt(D);
          rA = 1.0 / Ap;

          t1 = (Bp - D) * rA;
          t2 = (Bp + D) * rA;

          f1 = ((q1 >= q2 && q1 >= 0.0) && (q3 > q2 || q3 < 0.0));
          f2 = ((q3 > q2 && q3 > 0.0) && (q1 >= q2 || q1 <= 0.0));
        }
      else
        {
          t1 = t2 = 0.0;
          f1 = f2 = false;
        }
    }
  else
    {
      isignA = 1;
      t1 = t2 = 0.5 * C.y / B.y;

      f1 = (curve.p0.y >= 0.0 && curve.p2.y < 0.0);
      f2 = (curve.p0.y <= 0.0 && curve.p2.y > 0.0);
    }

  x1 = (A.x * t1 - B.x * 2.0) * t1 + C.x;
  x2 = (A.x * t2 - B.x * 2.0) * t2 + C.x;
  return vec2(x1, x2);
}

void
fastuidraw_banded_rays_compute_coverage_from_band(in uint curve_offset,
                                                  in uint num_curves,
                                                  in vec2 glyph_coord,
                                                  in float em, in int s,
                                                  out int winding,
                                                  inout fastuidraw_banded_rays_distance_type nv)
{
  winding = 0;
  for (uint c = 0u, curve_src = curve_offset; c < num_curves; curve_src += 3u, ++c)
    {
      fastuidraw_banded_rays_curve curve;

      fastuidraw_banded_rays_load_curve(curve_src, curve);

      /* translate the curve so that glyph_coord is the origin */
      curve.p0 -= glyph_coord;
      curve.p1 -= glyph_coord;
      curve.p2 -= glyph_coord;

      if (s > 0.0 && max(curve.p0.x, max(curve.p1.x, curve.p2.x)) * em < -0.5) break;
      if (s < 0.0 && min(curve.p0.x, min(curve.p1.x, curve.p2.x)) * em > 0.5) break;

        {
          vec2 x1x2;
          float x1, x2;
          bool f1, f2;
          int f;

          x1x2 = em * fastuidraw_banded_rays_intersect_y_equals_0(curve, f1, f2, f);
          x1 = x1x2.x;
          x2 = x1x2.y;

          if (f1)
            {
              if (s * x1 > 0.0)
                {
                  winding += f;
                }
              fastuidraw_banded_rays_update_distance(abs(x1), f > 0, nv);
            }

          if (f2)
            {
              if (s * x2 > 0.0)
                {
                  winding -= f;
                }
              fastuidraw_banded_rays_update_distance(abs(x2), f < 0, nv);
            }
        }
    }
}
///@endcond

/*!
 * Compute the coverage of a fragment within a \ref fastuidraw::GlyphRenderDataBandedRays glyph.
 * \param glyph_data_location location of the glyph data (see \ref
 *                            fastuidraw::GlyphRenderDataBandedRays::glyph_offset)
 * \param glyph_coord the coordinate of the fragment in glyph coordinates
 * \param glyph_coord_fwidth the value of fwidth(glyph_coord)
 * \param num_vertical_bands the number of vertical bands of the glyph, see \ref
 *                           fastuidraw::GlyphRenderDataBandedRays::glyph_num_vertical_bands
 * \param num_horizontal_bands the number of horizontal bands of the glyph, see \ref
 *                             fastuidraw::GlyphRenderDataBandedRays::glyph_num_horizontal_bands
 * \param use_odd_even_rule if true, use the odd-even fill rule, otherwise use the non-zero fill rule.
 */
float
fastuidraw_banded_rays_compute_coverage(in uint glyph_data_location,
                                        in vec2 glyph_coord,
                                        in vec2 glyph_coord_fwidth,
                                        in uint num_vertical_bands,
                                        in uint num_horizontal_bands,
                                        in bool use_odd_even_rule)
{
  uint horiz_band_offset, vert_band_offset;
  uint c, curve_src, num_curves, curve_offset;
  vec2 em, band_factor;
  fastuidraw_banded_rays_distance_type nv;
  ivec2 winding;
  int sx, sy;
  uint horiz_band, vert_band;
  fastuidraw_banded_rays_band horiz_band_data, vert_band_data;

  em = vec2(1.0, 1.0) / glyph_coord_fwidth;
  fastuidraw_banded_rays_init_distance(nv);

  /* Glyph coord varies -exactly- as [-G, G]x[-G, G]
   * where G = fastuidraw_banded_rays_glyph_coord.
   * So to figure out which band, we need to renormalized
   * [-G, G]x[-G, G] to [0, V]x[0, H].
   */
  band_factor = fastuidraw_banded_rays_glyph_coord_half_recip * vec2(num_vertical_bands, num_horizontal_bands);
  vert_band = min(num_vertical_bands - 1u,
                  uint(band_factor.x * (glyph_coord.x + fastuidraw_banded_rays_glyph_coord)));
  horiz_band = min(num_horizontal_bands - 1u,
                   uint(band_factor.y * (glyph_coord.y + fastuidraw_banded_rays_glyph_coord)));

  /* choose which bands */
  horiz_band_offset = horiz_band;
  if (glyph_coord.x < 0.0)
    {
      horiz_band_offset += num_horizontal_bands;
      sx = -1;
    }
  else
    {
      sx = 1;
    }

  vert_band_offset = vert_band + 2u * num_horizontal_bands;
  if (glyph_coord.y < 0.0)
    {
      vert_band_offset += num_vertical_bands;
      sy = -1;
    }
  else
    {
      sy = +1;
    }

  /* load the horizontal and vertical band headers */
  fastuidraw_banded_rays_load_band(glyph_data_location + horiz_band_offset, horiz_band_data);
  fastuidraw_banded_rays_load_band(glyph_data_location + vert_band_offset, vert_band_data);

  /* TODO: is it better to have a common loop with slightly more icky logic inside
   * to handle both cases simutaneously or to have a top level if() and each case
   * has their own loop?
   *  Pros for common loop: if fragments are across the line with a single frag-shader
   *                        dispatch, this significantly reduces the code divergence
   *
   *  Cons for common loop: We add (up to) two multiplies per curve (the sx multiply)
   *                        and an additional 2-mins or 2-maxes per curve for the early
   *                        out test.
   */
  fastuidraw_banded_rays_compute_coverage_from_band(horiz_band_data.curve_offset + glyph_data_location,
                                                    horiz_band_data.num_curves, glyph_coord,
                                                    em.x, sx, winding.x, nv);

  /* the curves for the vertical bands are saved with the x-coordinate
   * and y-coordinate swapped; this way we can avoid writing more
   * routines (to handle the xy-swapping) and just swap the xy-coords
   * of glyph_coords.
   */
  fastuidraw_banded_rays_compute_coverage_from_band(vert_band_data.curve_offset + glyph_data_location,
                                                    vert_band_data.num_curves, glyph_coord.yx,
                                                    em.y, sy, winding.y, nv);

  float distance, cvg;
  int winding_number = winding.x;

  if (winding_number == 0 || use_odd_even_rule)
    {
      distance = min(nv.distance_increment,
                     nv.distance_decrement);
    }
  else if (winding_number == -1)
    {
      distance = nv.distance_increment;
    }
  else if (winding_number == 1)
    {
      distance = nv.distance_decrement;
    }
  else
    {
      distance = 0.5;
    }

  distance = min(distance, 0.5);
  winding_number = (use_odd_even_rule && (winding_number & 1) == 0) ? 0 : winding_number;
  cvg = (winding_number != 0) ?
    (0.5 + distance) :
    (0.5 - distance);

  return cvg;
}
/*! @} */
