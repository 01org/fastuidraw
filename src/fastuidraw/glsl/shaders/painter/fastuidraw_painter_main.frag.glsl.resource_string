/*!
 * \file fastuidraw_painter_main.frag.glsl.resource_string
 * \brief file fastuidraw_painter_main.frag.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@intel.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@intel.com>
 *
 */

#ifdef FASTUIDRAW_PAINTER_BLEND_DUAL_SRC_BLEND
  layout(location = 0, index = 0) out vec4 fastuidraw_final_color0;
  layout(location = 0, index = 1) out vec4 fastuidraw_final_color1;
#elif defined(FASTUIDRAW_PAINTER_BLEND_SINGLE_SRC_BLEND)
  layout(location = 0) out vec4 fastuidraw_final_color;
#elif defined(FASTUIDRAW_PAINTER_BLEND_FRAMEBUFFER_FETCH)
  layout(location = 0) inout vec4 fastuidraw_final_color;
#elif defined(FASTUIDRAW_PAINTER_BLEND_INTERLOCK)
  layout(binding = FASTUIDRAW_PAINTER_BLEND_INTERLOCK_BINDING, rgba8) coherent restrict lowp uniform image2D fastuidraw_color_buffer;
#endif

#ifdef FASTUIDRAW_PAINTER_CLIPPING_USE_DISCARD

  bool
  fastuidraw_apply_clipping(void)
  {
    if (fastuidraw_clip_plane0 < 0.0 || fastuidraw_clip_plane1 < 0.0
       || fastuidraw_clip_plane2 < 0.0  || fastuidraw_clip_plane3 < 0.0)
      {
        FASTUIDRAW_DISCARD;
      }
    return false;
  }

#elif defined(FASTUIDRAW_PAINTER_CLIPPING_SKIP_COLOR_WRITE)
  #if !defined(FASTUIDRAW_PAINTER_BLEND_FRAMEBUFFER_FETCH) && !defined(FASTUIDRAW_PAINTER_BLEND_INTERLOCK)
    #error "Using FASTUIDRAW_PAINTER_CLIPPING_SKIP_COLOR_WRITE without FASTUIDRAW_PAINTER_BLEND_FRAMEBUFFER_FETCH or FASTUIDRAW_PAINTER_BLEND_INTERLOCK"
  #endif

  bool
  fastuidraw_apply_clipping(void)
  {
    return (fastuidraw_clip_plane0 < 0.0 || fastuidraw_clip_plane1 < 0.0
            || fastuidraw_clip_plane2 < 0.0  || fastuidraw_clip_plane3 < 0.0);
  }

#else

  bool
  fastuidraw_apply_clipping(void)
  {
    return false;
  }

#endif


void
main(void)
{
  vec4 v = vec4(0.0);
  vec2 pbrush, pbrush_dx, pbrush_dy;
  bool discard_color_write;

  discard_color_write = fastuidraw_apply_clipping();
  pbrush = vec2(fastuidraw_brush_p_x, fastuidraw_brush_p_y);
  pbrush_dx = dFdx(pbrush);
  pbrush_dy = dFdy(pbrush);

  #if defined(FASTUIDRAW_PAINTER_CLIPPING_SKIP_COLOR_WRITE)
  if (!discard_color_write
      || dFdx(float(discard_color_write)) != 0.0
      || dFdy(float(discard_color_write)) != 0.0)
  #endif
    {
      vec4 b, c;

      #ifdef FASTUIDRAW_PAINTER_UNPACK_AT_FRAGMENT_SHADER
        {
          fastuidraw_header h;

          fastuidraw_read_header(fastuidraw_header_varying, h);

          fastuidraw_frag_shader = h.item_shader;
          fastuidraw_frag_shader_data_location = h.item_shader_data_location;
          fastuidraw_blend_shader = h.blend_shader;
          fastuidraw_blend_shader_data_location = h.blend_shader_data_location;
          fastuidraw_deferred_buffer_offset_packed = h.deferred_buffer_offset_packed;

          uint brush_data_loc;
          brush_data_loc = h.brush_shader_data_location;
          fastuidraw_painter_brush_unpack_values(h.brush_shader, brush_data_loc);
        }
      #endif

      /* unpack fastuidraw_deferred_buffer_offset_packed to
       * fastuidraw_deferred_buffer_offset
       */
      uvec2 tmp;

      tmp.x = FASTUIDRAW_EXTRACT_BITS(fastuidraw_deferred_offset_x_bit0,
                                      fastuidraw_deferred_offset_coord_num_bits,
                                      fastuidraw_deferred_buffer_offset_packed);

      tmp.y = FASTUIDRAW_EXTRACT_BITS(fastuidraw_deferred_offset_y_bit0,
                                      fastuidraw_deferred_offset_coord_num_bits,
                                      fastuidraw_deferred_buffer_offset_packed);

      fastuidraw_deferred_buffer_offset = ivec2(tmp) - ivec2(fastuidraw_deferred_offset_bias,
                                                             fastuidraw_deferred_offset_bias);

      if (fastuidraw_blend_shader_data_location != FASTUIDRAW_HEADER_DRAWING_OCCLUDER)
        {
          c = fastuidraw_run_frag_shader(fastuidraw_frag_shader, fastuidraw_frag_shader_data_location);
          b = fastuidraw_compute_brush_color(pbrush, pbrush_dx, pbrush_dy);
          v = b * c;
        }
      else
        {
          v = vec4(0.0);
          discard_color_write = true;
        }
    }

  // The standard canvas pipeline emits pre-multiplied alpha surfaces
  v.rgb *= v.a;

  #ifdef FASTUIDRAW_PAINTER_BLEND_DUAL_SRC_BLEND
    {
      fastuidraw_run_blend_shader(fastuidraw_blend_shader,
                                  fastuidraw_blend_shader_data_location,
                                  v, fastuidraw_final_color0, fastuidraw_final_color1);
    }
  #elif defined(FASTUIDRAW_PAINTER_BLEND_SINGLE_SRC_BLEND)
    {
      fastuidraw_run_blend_shader(fastuidraw_blend_shader,
                                  fastuidraw_blend_shader_data_location,
                                  v, fastuidraw_final_color);
    }
  #elif defined(FASTUIDRAW_PAINTER_BLEND_FRAMEBUFFER_FETCH)
    {
      vec4 in_fb, out_fb;

      in_fb = fastuidraw_final_color;
      if (!discard_color_write)
        {
          fastuidraw_run_blend_shader(fastuidraw_blend_shader,
                                      fastuidraw_blend_shader_data_location,
                                      v, in_fb, out_fb);
        }
      else
        {
          out_fb = in_fb;
        }
      fastuidraw_final_color = out_fb;
    }
  #elif defined(FASTUIDRAW_PAINTER_BLEND_INTERLOCK)
    {
      fastuidraw_begin_interlock();
      if (!discard_color_write)
        {
          vec4 in_fb, out_fb;
          ivec2 pos = ivec2(gl_FragCoord.xy);

          in_fb = imageLoad(fastuidraw_color_buffer, pos);
          fastuidraw_run_blend_shader(fastuidraw_blend_shader,
                                      fastuidraw_blend_shader_data_location,
                                      v, in_fb, out_fb);
          imageStore(fastuidraw_color_buffer, pos, out_fb);
        }
      fastuidraw_end_interlock();
    }
  #endif
}
