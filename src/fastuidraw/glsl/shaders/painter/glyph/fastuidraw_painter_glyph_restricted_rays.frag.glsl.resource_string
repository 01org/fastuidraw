/*!
 * \file fastuidraw_painter_glyph_restricted_rays.frag.glsl.resource_string
 * \brief file fastuidraw_painter_glyph_restricted_rays.frag.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@intel.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@intel.com>
 *
 */

struct FASTUIDRAW_LOCAL(transformation_type)
{
  vec2 translation;
  vec2 r_vector, jr_vector;
};

struct FASTUIDRAW_LOCAL(curve_type)
{
  vec2 A, B, C, p1, p2, p3;
  bool is_quadratic;
};

struct FASTUIDRAW_LOCAL(box_type)
{
  vec2 min_point, max_point, center_point, size;
};

struct FASTUIDRAW_LOCAL(distance_values)
{
  float distance;
};

uint
FASTUIDRAW_LOCAL(compute_box)(in vec2 p,
                              out FASTUIDRAW_LOCAL(box_type) box,
                              out uint curve_list,
                              out uint num_curves)
{
  uint v, offset;

  box.min_point = vec2(fastuidraw_glyph_min_x, fastuidraw_glyph_min_y);
  box.max_point = vec2(fastuidraw_glyph_max_x, fastuidraw_glyph_max_y);

  offset = fastuidraw_glyph_data_location;
  v = fastuidraw_fetch_glyph_data(offset);

  while((v & HIERARCHY_NODE_MASK) != 0u)
    {
      uint c, bit0;
      float split_pt;
      bool take_max_choice;

      c = FASTUIDRAW_EXTRACT_BITS(HIERARCHY_SPLIT_COORD_BIT, 1u, v);
      if (c == 0u)
        {
          split_pt = 0.5 * (box.min_point.x + box.max_point.x);
          take_max_choice = (p.x > split_pt);
          box.min_point.x = (take_max_choice) ? split_pt : box.min_point.x;
          box.max_point.x = (take_max_choice) ? box.max_point.x : split_pt;
        }
      else
        {
          split_pt = 0.5 * (box.min_point.y + box.max_point.y);
          take_max_choice = (p.y > split_pt);
          box.min_point.y = (take_max_choice) ? split_pt : box.min_point.y;
          box.max_point.y = (take_max_choice) ? box.max_point.y : split_pt;
        }

      bit0 = (take_max_choice) ? HIERARCHY_CHILD1_BIT : HIERARCHY_CHILD0_BIT;
      offset = FASTUIDRAW_EXTRACT_BITS(bit0, HIERARCHY_CHILD_NUM_BITS, v);
      offset += fastuidraw_glyph_data_location;
      v = fastuidraw_fetch_glyph_data(offset);
    }

  box.size = box.max_point - box.min_point;
  box.center_point = 0.5 * (box.min_point + box.max_point);
  curve_list = FASTUIDRAW_EXTRACT_BITS(HIERARCHY_CURVE_LIST_BIT0, HIERARCHY_CURVE_LIST_NUM_BITS, v);
  num_curves = FASTUIDRAW_EXTRACT_BITS(HIERARCHY_CURVE_LIST_SIZE_BIT0, HIERARCHY_CURVE_LIST_SIZE_NUM_BITS, v);

  return offset + 1u;
}

ivec2
FASTUIDRAW_LOCAL(unpack_point)(in uint ptr)
{
  uint pt_packed;
  uvec2 pt_u;
  ivec2 pt_i;

  pt_packed = fastuidraw_fetch_glyph_data(ptr);

  pt_u.x = FASTUIDRAW_EXTRACT_BITS(POINT_X_COORDINATE_BIT0, POINT_COORDINATE_NUM_BITS, pt_packed);
  pt_u.y = FASTUIDRAW_EXTRACT_BITS(POINT_Y_COORDINATE_BIT0, POINT_COORDINATE_NUM_BITS, pt_packed);
  pt_i = ivec2(pt_u);

  return pt_i;
}

void
FASTUIDRAW_LOCAL(compute_transformation)(in vec2 frag_point,
                                         in vec2 reference_point,
                                         out FASTUIDRAW_LOCAL(transformation_type) tr)
{
  vec2 q;

  q = reference_point - frag_point;
  q /= dot(q, q);

  tr.translation = frag_point;
  tr.r_vector = q;
  tr.jr_vector.x = -tr.r_vector.y;
  tr.jr_vector.y = tr.r_vector.x;
}

void
FASTUIDRAW_LOCAL(compute_frag_transformation)(in vec2 frag_point,
                                              in vec2 uv_dx,
                                              in vec2 uv_dy,
                                              out FASTUIDRAW_LOCAL(transformation_type) tr)
{
  float det, recip_det;

  det = uv_dx.x * uv_dy.y - uv_dx.y * uv_dy.x;
  recip_det = 1.0 / det;

  tr.r_vector.x = uv_dy.y * recip_det;
  tr.r_vector.y = -uv_dy.x * recip_det;
  tr.jr_vector.x = -uv_dx.y * recip_det;
  tr.jr_vector.y = uv_dx.x * recip_det;
  tr.translation = frag_point;
}

vec2
FASTUIDRAW_LOCAL(apply_transformation)(in vec2 p,
                                       in FASTUIDRAW_LOCAL(transformation_type) tr)
{
  p -= tr.translation;
  return vec2(dot(tr.r_vector, p),
              dot(tr.jr_vector, p));
}

vec2
FASTUIDRAW_LOCAL(apply_rotation_only)(in vec2 p,
                                      in FASTUIDRAW_LOCAL(transformation_type) tr)
{
  return vec2(dot(tr.r_vector, p),
              dot(tr.jr_vector, p));
}

int
FASTUIDRAW_LOCAL(process_curve)(in vec2 p1, in vec2 p2, in vec2 p3,
                                in vec2 A, in vec2 B, in vec2 C,
                                in bool is_curve)
{
  int R = 0;
  uint code;

  code = (p1.y > 0.0 ? 2u : 0u)
    + (p2.y > 0.0 ? 4u : 0u)
    + (p3.y > 0.0 ? 8u : 0u);

  code = (0x2E74u >> code) & 0x3u;
  if (code != 0u)
    {
      float t1, t2, x1, x2;
      const float quad_tol = 0.0001;

      if (is_curve && abs(A.y) > quad_tol)
        {
          float D, rA = 1.0 / A.y;

          D = B.y * B.y - A.y * C.y;

          D = sqrt(max(D, 0.0));
          t1 = (B.y - D) * rA;
          t2 = (B.y + D) * rA;
        }
      else
        {
          t1 = t2 = 0.5 * C.y / B.y;
        }

      x1 = (A.x * t1 - B.x * 2.0) * t1 + C.x;
      x2 = (A.x * t2 - B.x * 2.0) * t2 + C.x;

      if ((code & 1u) != 0u && x1 < 1.0 && x1 > 0.0)
        {
          R += 1;
        }

      if (code > 1u && x2 < 1.0 && x2 > 0.0)
        {
          R -= 1;
        }
    }

  return R;
}

void
FASTUIDRAW_LOCAL(compute_l1_distance_y_fixed)(in vec2 p1, in vec2 p2, in vec2 p3,
                                              in vec2 A, in vec2 B, in vec2 C,
                                              in bool is_curve,
                                              inout FASTUIDRAW_LOCAL(distance_values) value)
{
  uint code;

  code = (p1.y > 0.0 ? 2u : 0u)
    + (p2.y > 0.0 ? 4u : 0u)
    + (p3.y > 0.0 ? 8u : 0u);

  code = (0x2E74u >> code) & 0x3u;
  if (code != 0u)
    {
      float t1, t2;
      vec2 p1, p2;
      const float quad_tol = 0.0001;

      if (is_curve && abs(A.y) > quad_tol)
        {
          float D, rA = 1.0 / A.y;

          D = B.y * B.y - A.y * C.y;
          D = sqrt(max(D, 0.0));
          t1 = (B.y - D) * rA;
          t2 = (B.y + D) * rA;
        }
      else
        {
          t1 = t2 = 0.5 * C.y / B.y;
        }

      t1 = clamp(t1, 0.0, 1.0);
      t2 = clamp(t2, 0.0, 1.0);

      p1 = (A * t1 - B * 2.0) * t1 + C;
      p2 = (A * t2 - B * 2.0) * t2 + C;

      if ((code & 1u) != 0u)
        {
          //R += 1.0;
          value.distance = min(value.distance, abs(p1.x) + abs(p1.y));
        }

      if (code > 1u)
        {
          //R -= 1.0;
          value.distance = min(value.distance, abs(p2.x) + abs(p2.y));
        }
    }
}

void
FASTUIDRAW_LOCAL(compute_l1_distance_endpoints)(in vec2 p1, in vec2 p2, in vec2 p3,
                                                inout FASTUIDRAW_LOCAL(distance_values) value)
{
  float v;
  v = min(abs(p1.x) + abs(p1.y), abs(p3.x) + abs(p3.y));
  value.distance = min(value.distance, v);
}

void
FASTUIDRAW_LOCAL(compute_l1_distance_curve_critical)(in vec2 p1, in vec2 p2, in vec2 p3,
                                                     in vec2 A, in vec2 B, in vec2 C,
                                                     inout FASTUIDRAW_LOCAL(distance_values) value)
{
  /* find those t for which |x'(t)| = |y'(t)|
   * which is just those t for which
   *
   *  x'(t) - y'(t) = 0 or x'(t) + y'(t) = 0
   *
   * Now,
   *
   *   p(t) = (A * t - B * 2.0) * t + C
   *
   * thus,
   *
   *   p'(t) = 2.0 * ( A * t - B)
   *
   * thus the t's are t0 and t1 where
   *
   *  (A.x * t0 - B.x) + (A.y * t0 - B.y) = 0 --> t0 = (B.x + B.y) / (A.x + A.y)
   *  (A.x * t1 - B.x) - (A.y * t1 - B.y) = 0 --> t1 = (B.x - B.y) / (A.x - A.y)
   */

  float d0, d1, n0, n1;
  const float tol = 0.0001;

  n0 = B.x + B.y;
  d0 = A.x + A.y;
  n0 *= sign(d0);
  d0 = abs(d0);

  n1 = B.x - B.y;
  d1 = A.x - A.y;
  n1 *= sign(d1);
  d1 = abs(d1);

  if (n0 > 0.0 && d0 > n0)
    {
      float t0, v;
      vec2 p;

      t0 = n0 / d0;
      p = (A * t0 - 2.0 * B) * t0 + C;
      v = abs(p.x) + abs(p.y);
      value.distance = min(value.distance, v);
    }

  if (n1 > 0.0 && d1 > n1)
    {
      float t1, v;
      vec2 p;

      t1 = n1 / d1;
      p = (A * t1 - 2.0 * B) * t1 + C;
      v = abs(p.x) + abs(p.y);
      value.distance = min(value.distance, v);
    }
}

vec2
FASTUIDRAW_LOCAL(rotate_90_degrees)(vec2 v)
{
  return vec2(v.y, -v.x);
}

void
FASTUIDRAW_LOCAL(compute_l1_distance)(in vec2 p1, in vec2 p2, in vec2 p3,
                                      in vec2 A, in vec2 B, in vec2 C,
                                      in bool is_curve,
                                      inout FASTUIDRAW_LOCAL(distance_values) value)
{
  FASTUIDRAW_LOCAL(compute_l1_distance_y_fixed)(p1, p2, p3, A, B, C, is_curve, value);
  FASTUIDRAW_LOCAL(compute_l1_distance_y_fixed)(FASTUIDRAW_LOCAL(rotate_90_degrees)(p1),
                                                FASTUIDRAW_LOCAL(rotate_90_degrees)(p2),
                                                FASTUIDRAW_LOCAL(rotate_90_degrees)(p3),
                                                FASTUIDRAW_LOCAL(rotate_90_degrees)(A),
                                                FASTUIDRAW_LOCAL(rotate_90_degrees)(B),
                                                FASTUIDRAW_LOCAL(rotate_90_degrees)(C),
                                                is_curve, value);
  FASTUIDRAW_LOCAL(compute_l1_distance_endpoints)(p1, p2, p3, value);
  if (is_curve)
    {
      FASTUIDRAW_LOCAL(compute_l1_distance_curve_critical)(p1, p2, p3, A, B, C, value);
    }
}

void
FASTUIDRAW_LOCAL(load_curve)(in uint raw,
                             in uint glyph_data_location,
                             out FASTUIDRAW_LOCAL(curve_type) curve)
{
  uint curve_src;
  ivec2 ip1, ip3, iA, i2B, iC;

  curve_src = glyph_data_location + FASTUIDRAW_EXTRACT_BITS(CURVE_BIT0, CURVE_NUM_BITS, raw);
  curve.is_quadratic = (raw & CURVE_IS_QUADRATIC_MASK) != 0u;

  if (curve.is_quadratic)
    {
      ivec2 ip2;

      ip1 = FASTUIDRAW_LOCAL(unpack_point)(curve_src);
      ip2 = FASTUIDRAW_LOCAL(unpack_point)(curve_src + 1u);
      ip3 = FASTUIDRAW_LOCAL(unpack_point)(curve_src + 2u);

      iA = ip1 - 2 * ip2 + ip3;
      i2B = 2 * (ip1 - ip2);
      iC = ip1;

      curve.p2 = vec2(ip2);
    }
  else
    {
      ivec2 ip2;

      ip1 = FASTUIDRAW_LOCAL(unpack_point)(curve_src);
      ip3 = FASTUIDRAW_LOCAL(unpack_point)(curve_src + 1u);

      /* ip2 is 0.5 * (ip1 + ip3) */
      iA = ivec2(0, 0);
      i2B = ip1 - ip3;
      iC = ip1;

      curve.p2 = 0.5 * vec2(ip1 + ip3);
    }

  curve.p1 = vec2(ip1);
  curve.p3 = vec2(ip3);

  curve.A = vec2(iA);
  curve.B = vec2(i2B) * 0.5;
  curve.C = vec2(iC);
}

int
FASTUIDRAW_LOCAL(load_and_process_curve)(in uint raw,
                                         in uint glyph_data_location,
                                         in FASTUIDRAW_LOCAL(transformation_type) tr,
                                         in FASTUIDRAW_LOCAL(transformation_type) frag_tr,
                                         inout FASTUIDRAW_LOCAL(distance_values) nv)
{
  FASTUIDRAW_LOCAL(curve_type) curve_data;
  int return_value;

  FASTUIDRAW_LOCAL(load_curve)(raw,
                               fastuidraw_glyph_data_location,
                               curve_data);


  /* We need to process the curve transformed by the given transformation.
   * However, the values of A, B, C require more care:
   *   A = p1 - 2 * p2 + p3 --> applying transformation to each of p's and computing A
   *                            gives that A is NOT affected by the translation
   *   B = 2 * (p1 - p2)    --> applying transformation to each of p's and computing B
   *                            gives that B is NOT affected by the translation
   *   C = p3               --> applying transformation to each of p's and computing C
   *                            gives that C IS affected by the translation
   */
  return_value = FASTUIDRAW_LOCAL(process_curve)(FASTUIDRAW_LOCAL(apply_transformation)(curve_data.p1, tr),
                                                 FASTUIDRAW_LOCAL(apply_transformation)(curve_data.p2, tr),
                                                 FASTUIDRAW_LOCAL(apply_transformation)(curve_data.p3, tr),
                                                 FASTUIDRAW_LOCAL(apply_rotation_only)(curve_data.A, tr),
                                                 FASTUIDRAW_LOCAL(apply_rotation_only)(curve_data.B, tr),
                                                 FASTUIDRAW_LOCAL(apply_transformation)(curve_data.C, tr),
                                                 curve_data.is_quadratic);

  FASTUIDRAW_LOCAL(compute_l1_distance)(FASTUIDRAW_LOCAL(apply_transformation)(curve_data.p1, frag_tr),
                                        FASTUIDRAW_LOCAL(apply_transformation)(curve_data.p2, frag_tr),
                                        FASTUIDRAW_LOCAL(apply_transformation)(curve_data.p3, frag_tr),
                                        FASTUIDRAW_LOCAL(apply_rotation_only)(curve_data.A, frag_tr),
                                        FASTUIDRAW_LOCAL(apply_rotation_only)(curve_data.B, frag_tr),
                                        FASTUIDRAW_LOCAL(apply_transformation)(curve_data.C, frag_tr),
                                        curve_data.is_quadratic,
                                        nv);
  return return_value;
}

int
FASTUIDRAW_LOCAL(load_winding_reference)(in uint location,
                                         in FASTUIDRAW_LOCAL(box_type) box,
                                         in vec2 frag_position,
                                         out vec2 position)
{
  uint texel, biased_winding;
  uvec2 biased_delta;
  vec2 delta;

  position = box.center_point;
  texel = fastuidraw_fetch_glyph_data(location);

  biased_winding = FASTUIDRAW_EXTRACT_BITS(WINDING_VALUE_BIT0, WINDING_VALUE_NUM_BITS, texel);
  biased_delta.x = FASTUIDRAW_EXTRACT_BITS(POSITION_DELTA_X_BIT0, POSITION_DELTA_NUM_BITS, texel);
  biased_delta.y = FASTUIDRAW_EXTRACT_BITS(POSITION_DELTA_Y_BIT0, POSITION_DELTA_NUM_BITS, texel);

  delta = vec2(biased_delta) - vec2(float(POSITION_DELTA_BIAS));
  delta /= float(POSITION_DELTA_DIVIDE);
  position += delta;

  return int(biased_winding) - int(WINDING_VALUE_BIAS);
}

vec4
fastuidraw_gl_frag_main(in uint sub_shader,
                        in uint shader_data_offset)
{
  uint src, num_curves, c, curve_list, winding_sample_data_location;
  vec2 z, glyph_coord, glyph_coord_dx, glyph_coord_dy;
  int startw, winding_number;
  FASTUIDRAW_LOCAL(box_type) texel_box;
  FASTUIDRAW_LOCAL(transformation_type) tr, frag_tr;
  FASTUIDRAW_LOCAL(distance_values) nv;

  glyph_coord = vec2(fastuidraw_glyph_coord_x,
                    fastuidraw_glyph_coord_y);
  glyph_coord_dx = dFdx(glyph_coord);
  glyph_coord_dy = dFdy(glyph_coord);

  winding_sample_data_location = FASTUIDRAW_LOCAL(compute_box)(glyph_coord, texel_box,
                                                               curve_list, num_curves);
  nv.distance = 0.5;

  startw = FASTUIDRAW_LOCAL(load_winding_reference)(winding_sample_data_location,
                                                    texel_box, glyph_coord, z);

  winding_number = startw;
  FASTUIDRAW_LOCAL(compute_transformation)(glyph_coord, z, tr);

  /* To perform anisotropic anti-aliasing, we simply compute the L1-distance
   * function is (local) pixel coordinates. To do so, we comptue the transformation
   * from glyph coordinates to window coordinates and do the computation there.
   */
  FASTUIDRAW_LOCAL(compute_frag_transformation)(glyph_coord, glyph_coord_dx, glyph_coord_dy, frag_tr);

  src = curve_list + fastuidraw_glyph_data_location;
  for (c = 0u; c < num_curves; c += 2u)
    {
      uint cA, cB, curve_pair;

      curve_pair = fastuidraw_fetch_glyph_data(src);
      ++src;

      cA = FASTUIDRAW_EXTRACT_BITS(CURVE_ENTRY0_BIT0, CURVE_ENTRY_NUM_BITS, curve_pair);
      winding_number += FASTUIDRAW_LOCAL(load_and_process_curve)(cA, fastuidraw_glyph_data_location, tr, frag_tr, nv);

      if (c + 1u < num_curves)
        {
          cB = FASTUIDRAW_EXTRACT_BITS(CURVE_ENTRY1_BIT0, CURVE_ENTRY_NUM_BITS, curve_pair);
          winding_number += FASTUIDRAW_LOCAL(load_and_process_curve)(cB, fastuidraw_glyph_data_location, tr, frag_tr, nv);
        }
    }

  float cvg;

  /* TODO: rather than tracking the minimum L1-distance,
   * we should track two minimum values: minimum distance
   * to a curve that increments the winding number and the
   * minimum distance to a curve that decrements the winding
   * number. If the winding number at the fragment is 0, use
   * the minimum of those two; if the winding value is 1
   * use the decrement value and if the winding is -1 use the
   * increment winding number; if the absolute value of the
   * winding value is greater than two, we will view the
   * fragment as fully covered.
   */
  cvg = (abs(winding_number) != 0) ?
    (0.5 + nv.distance) :
    (0.5 - nv.distance);

  /**
  const float tol = 3.0;
  float tol_x = tol * fwidth(glyph_coord.x);
  float tol_y = tol * fwidth(glyph_coord.y);
  vec3 ff = vec3(0.0, 0.0, cvg);
  if (abs(glyph_coord.x - texel_box.min_point.x) < tol_x
      || abs(glyph_coord.x - texel_box.max_point.x) < tol_x
      || abs(glyph_coord.y - texel_box.min_point.y) < tol_y
      || abs(glyph_coord.y - texel_box.max_point.y) < tol_y)
    {
      //ff.x = 1.0;
    }

  if (length(z - glyph_coord) < tol * min(fwidth(glyph_coord.x), fwidth(glyph_coord.y)))
    {
      //ff.y = 1.0;
    }

  if (startw == 0)
    {
      // ff.xy = ff.yx;
    }

  return vec4(ff, 1.0);
  **/

  return vec4(1.0, 1.0, 1.0, cvg);
}
