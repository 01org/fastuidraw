/*!
 * \file fastuidraw_restricted_rays.glsl.resource_string
 * \brief file fastuidraw_restricted_rays.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@intel.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@intel.com>
 *
 */

/* must have the macro/function
 *
 *  FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(X)
 *
 * that returns a single 32-bit uint value at index X of
 * a large array of 32-bit uint values storing the data
 */

struct fastuidraw_restricted_rays_transformation_base
{
  vec2 translation;
  vec2 r_vector, jr_vector;
};

struct fastuidraw_restricted_rays_transformation_ref
{
  fastuidraw_restricted_rays_transformation_base base;
  float reference_location;
};

struct fastuidraw_restricted_rays_transformation_frag
{
  fastuidraw_restricted_rays_transformation_base base;
  float orientation;
};

struct fastuidraw_restricted_rays_curve_type
{
  vec2 p1, p2, p3;
  bool is_quadratic;
};

struct fastuidraw_restricted_rays_box_type
{
  vec2 min_point, max_point, center_point, size;
};

struct fastuidraw_restricted_rays_distance_type
{
  float distance_increment;
  float distance_decrement;
};

struct fastuidraw_restricted_rays_winding_sample_type
{
  int reference_winding;
  vec2 reference_position;
};

void
fastuidraw_restricted_rays_init_distance(out fastuidraw_restricted_rays_distance_type nv)
{
  /* Just initialize to some value that is large (strictly speaking
   * we only need a value greater than 0.5, but make it larger
   * for debug renders to be useful).
   */
  nv.distance_increment = nv.distance_decrement = 120.0;
}

void
fastuidraw_restricted_rays_swap_distances(inout fastuidraw_restricted_rays_distance_type nv)
{
  float tmp;

  tmp = nv.distance_increment;
  nv.distance_increment = nv.distance_decrement;
  nv.distance_decrement = tmp;
}

void
fastuidraw_restricted_rays_update_distance(in float dist, in bool is_increment,
                                           inout fastuidraw_restricted_rays_distance_type nv)
{
  /* We are assuming that there are no cancelling curves in the glyph data.
   * The class GlyphRenderDataRestrictedRays has code to detect most forms
   * of cancelling curves (it detects partially overlapping vertical and
   * horizontal curves along with perfectly overlapping general curves).
   */
  if (is_increment)
    {
      nv.distance_increment = min(nv.distance_increment, dist);
    }
  else
    {
      nv.distance_decrement = min(nv.distance_decrement, dist);
    }
}

void
fastuidraw_restricted_rays_update_distance(in vec2 p, in bool is_increment,
                                           inout fastuidraw_restricted_rays_distance_type nv)
{
  float d;

  d = abs(p.x) + abs(p.y);
  fastuidraw_restricted_rays_update_distance(d, is_increment, nv);
}

void
fastuidraw_restricted_rays_update_distance(in vec2 p, in vec2 dp,
                                           inout fastuidraw_restricted_rays_distance_type nv)
{
  float z;

  z = p.x * dp.y - p.y * dp.x;
  fastuidraw_restricted_rays_update_distance(p, z > 0.0, nv);
}

uint
fastuidaw_restricted_rays_compute_box(in vec2 p,
                                      in vec2 bb_box_min, in vec2 bb_box_max,
                                      in uint data_location,
                                      out fastuidraw_restricted_rays_box_type box,
                                      out uint curve_list,
                                      out uint num_curves)
{
  uint v, offset;

  box.min_point = bb_box_min;
  box.max_point = bb_box_max;

  offset = data_location;
  v = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(offset);

  while((v & fastuidraw_restricted_rays_hierarchy_node_mask) != 0u)
    {
      uint c, bit0;
      float split_pt;
      bool take_max_choice;

      c = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_hierarchy_split_coord_bit, 1u, v);
      if (c == 0u)
        {
          split_pt = 0.5 * (box.min_point.x + box.max_point.x);
          take_max_choice = (p.x > split_pt);
          box.min_point.x = (take_max_choice) ? split_pt : box.min_point.x;
          box.max_point.x = (take_max_choice) ? box.max_point.x : split_pt;
        }
      else
        {
          split_pt = 0.5 * (box.min_point.y + box.max_point.y);
          take_max_choice = (p.y > split_pt);
          box.min_point.y = (take_max_choice) ? split_pt : box.min_point.y;
          box.max_point.y = (take_max_choice) ? box.max_point.y : split_pt;
        }

      bit0 = (take_max_choice) ?
        fastuidraw_restricted_rays_hierarchy_child1_bit:
        fastuidraw_restricted_rays_hierarchy_child0_bit;
      offset = FASTUIDRAW_EXTRACT_BITS(bit0,
                                       fastuidraw_restricted_rays_hierarchy_child_num_bits,
                                       v);
      offset += data_location;
      v = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(offset);
    }

  box.size = box.max_point - box.min_point;
  box.center_point = 0.5 * (box.min_point + box.max_point);
  curve_list = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_hierarchy_curve_list_bit0,
                                       fastuidraw_restricted_rays_hierarchy_curve_list_num_bits,
                                       v);
  num_curves = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_hierarchy_curve_list_size_bit0,
                                       fastuidraw_restricted_rays_hierarchy_curve_list_size_num_bits,
                                       v);

  return offset + 1u;
}

ivec2
fastuidraw_restricted_rays_unpack_point(in uint ptr)
{
  uint pt_packed;
  uvec2 pt_u;
  ivec2 pt_i;

  pt_packed = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(ptr);

  pt_u.x = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_point_x_coordinate_bit0,
                                   fastuidraw_restricted_rays_point_coordinate_num_bits,
                                   pt_packed);
  pt_u.y = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_point_y_coordinate_bit0,
                                   fastuidraw_restricted_rays_point_coordinate_num_bits,
                                   pt_packed);
  pt_i = ivec2(pt_u);

  return pt_i;
}

void
fastuidraw_restricted_rays_compute_transformation_base(in vec2 frag_point,
						       in vec2 reference_point,
						       out fastuidraw_restricted_rays_transformation_base tr)
{
  vec2 q;

  q = reference_point - frag_point;

  tr.translation = frag_point;
  tr.r_vector = q;
  tr.jr_vector.x = -tr.r_vector.y;
  tr.jr_vector.y = tr.r_vector.x;
}

void
fastuidraw_restricted_rays_compute_transformation(in vec2 frag_point,
                                                  in vec2 frag_point_dx,
                                                  in vec2 frag_point_dy,
                                                  in vec2 reference_point,
                                                  out fastuidraw_restricted_rays_transformation_ref tr)
{
  vec2 em;

  fastuidraw_restricted_rays_compute_transformation_base(frag_point, reference_point, tr.base);

  em.x = abs(dot(tr.base.r_vector, frag_point_dx)) + abs(dot(tr.base.r_vector, frag_point_dy));
  em.y = abs(dot(tr.base.jr_vector, frag_point_dx)) + abs(dot(tr.base.jr_vector, frag_point_dy));

  /* Prevent divide by zero. if em.x or em.y is very small, that means
   * that on screen the x (repsectively y) local coordinate axis is
   * severely stretched. Since the sample point is to be reasonably
   * far from any curve, clamping em.x and em.y away from zero will
   * not have effect on coverage computation.
   */
  const float min_em = 1e-7;
  em.x = 1.0 / max(em.x, min_em);
  em.y = 1.0 / max(em.y, min_em);

  tr.reference_location = em.x * dot(tr.base.r_vector, tr.base.r_vector);
  tr.base.r_vector *= em.x;
  tr.base.jr_vector *= em.y;
}

void
fastuidraw_restricted_rays_compute_transformation_frag(in vec2 frag_point,
						       in vec2 uv_dx,
						       in vec2 uv_dy,
						       out fastuidraw_restricted_rays_transformation_frag tr)
{
  float det, recip_det;

  det = uv_dx.x * uv_dy.y - uv_dx.y * uv_dy.x;
  recip_det = 1.0 / det;

  tr.base.r_vector.x = uv_dy.y * recip_det;
  tr.base.r_vector.y = -uv_dy.x * recip_det;
  tr.base.jr_vector.x = -uv_dx.y * recip_det;
  tr.base.jr_vector.y = uv_dx.x * recip_det;
  tr.base.translation = frag_point;
  tr.orientation = sign(det);
}

vec2
fastuidraw_restricted_rays_apply_transformation(in vec2 p,
                                                in fastuidraw_restricted_rays_transformation_base tr)
{
  p -= tr.translation;
  return vec2(dot(tr.r_vector, p),
              dot(tr.jr_vector, p));
}

uint
fastuidraw_restricted_rays_compute_code(in float y1, in float y2, in float y3)
{
  uint code;

  code = (y1 > 0.0 ? 2u : 0u)
    + (y2 > 0.0 ? 4u : 0u)
    + (y3 > 0.0 ? 8u : 0u);

  return (0x2E74u >> code) & 0x3u;
}

int
fastuidraw_restricted_rays_compute_winding_contribution_solver(in vec2 A, in vec2 B, in vec2 C,
							       in float reference_location, in uint code,
							       in float orientation,
							       in bool is_quadratic,
							       inout fastuidraw_restricted_rays_distance_type dst)
{
  int R = 0;

  if (code != 0u)
    {
      float t1, t2, x1, x2;
      const float quad_tol = 0.0001;

      if (is_quadratic && abs(A.y) > quad_tol)
        {
          float D, rA = 1.0 / A.y;

          D = B.y * B.y - A.y * C.y;
	  if (D < 0.0)
	    {
	      code = 0u;
	    }
	  else
	    {
	      D = sqrt(max(D, 0.0));
	      t1 = (B.y - D) * rA;
	      t2 = (B.y + D) * rA;
	    }
        }
      else
        {
          t1 = t2 = 0.5 * C.y / B.y;
        }

      x1 = (A.x * t1 - B.x * 2.0) * t1 + C.x;
      x2 = (A.x * t2 - B.x * 2.0) * t2 + C.x;

      if ((code & 1u) != 0u)
        {
          if (x1 <= reference_location && x1 >= 0.0)
            {
              R += 1;
            }

          if (t1 >= 0.0 && t1 <= 1.0)
            {
              fastuidraw_restricted_rays_update_distance(abs(x1), orientation * x1 < 0.0, dst);
            }
        }

      if (code > 1u)
        {
          if (x2 <= reference_location && x2 >= 0.0)
            {
              R -= 1;
            }

          if (t2 >= 0.0 && t2 <= 1.0)
            {
              fastuidraw_restricted_rays_update_distance(abs(x2), orientation * x2 > 0.0, dst);
            }
        }
    }

  return R;
}

int
fastuidraw_restricted_rays_compute_winding_contribution(in fastuidraw_restricted_rays_curve_type curve,
                                                        in fastuidraw_restricted_rays_transformation_ref tr,
                                                        inout fastuidraw_restricted_rays_distance_type dst)
{
  vec2 A, B, C;
  int R;
  uvec2 code;

  curve.p1 = fastuidraw_restricted_rays_apply_transformation(curve.p1, tr.base);
  curve.p2 = fastuidraw_restricted_rays_apply_transformation(curve.p2, tr.base);
  curve.p3 = fastuidraw_restricted_rays_apply_transformation(curve.p3, tr.base);

  A = curve.p1 - 2.0 * curve.p2 + curve.p3;
  B = curve.p1 - curve.p2;
  C = curve.p1;

  code.x = fastuidraw_restricted_rays_compute_code(curve.p1.x, curve.p2.x, curve.p3.x);
  code.y = fastuidraw_restricted_rays_compute_code(curve.p1.y, curve.p2.y, curve.p3.y);

  R = fastuidraw_restricted_rays_compute_winding_contribution_solver(A, B, C, tr.reference_location,
								     code.y, 1.0, curve.is_quadratic, dst);
  fastuidraw_restricted_rays_compute_winding_contribution_solver(A.yx, B.yx, C.yx, tr.reference_location,
								 code.x, -1.0, curve.is_quadratic, dst);

  /* When computing the L1-distance, we also need to minimum with the
   * endpoint of the curve. In glyph coordinates, the curve is given by:
   *
   *  p(t) = (A * t - 2B) * t + C
   *
   * so
   *
   *  p'(t) = 2At - 2B
   */
  vec2 dp1, dp3;

  dp1 = -B;
  dp3 = A - B;
  fastuidraw_restricted_rays_update_distance(curve.p1, dp1, dst);
  fastuidraw_restricted_rays_update_distance(curve.p3, dp3, dst);

  /* The last ingredient of minimizing the L1-distance is to minimize
   * against those t for which:
   *
   *   x'(t) - y'(t) = 0 or x'(t) + y'(t) = 0
   *
   * thus the t's are t0 and t1 where
   *
   * (A.x * t0 - B.x) + (A.y * t0 - B.y) = 0 --> t0 = (B.x + B.y) / (A.x + A.y)
   * (A.x * t1 - B.x) - (A.y * t1 - B.y) = 0 --> t1 = (B.x - B.y) / (A.x - A.y)
   *
   */
  if (curve.is_quadratic)
    {
      float d0, d1, n0, n1;
      const float tol = 0.0001;

      n0 = B.x + B.y;
      d0 = A.x + A.y;
      n0 *= sign(d0);
      d0 = abs(d0);

      n1 = B.x - B.y;
      d1 = A.x - A.y;
      n1 *= sign(d1);
      d1 = abs(d1);

      if (n0 > 0.0 && d0 > n0)
        {
          float t0;
          vec2 p, dp;

          t0 = n0 / d0;
          p = (A * t0 - 2.0 * B) * t0 + C;
          dp = A * t0 - B;
          fastuidraw_restricted_rays_update_distance(p, dp, dst);
        }

      if (n1 > 0.0 && d1 > n1)
        {
          float t1;
          vec2 p, dp;

          t1 = n1 / d1;
          p = (A * t1 - 2.0 * B) * t1 + C;
          dp = A * t1 - B;
          fastuidraw_restricted_rays_update_distance(p, dp, dst);
        }
    }

  return R;
}

int
fastuidraw_restricted_rays_compute_winding_contribution_only(in fastuidraw_restricted_rays_curve_type curve,
							     in fastuidraw_restricted_rays_transformation_ref tr)
{
  vec2 A, B, C;
  int R = 0;
  uint code;

  curve.p1 = fastuidraw_restricted_rays_apply_transformation(curve.p1, tr.base);
  curve.p2 = fastuidraw_restricted_rays_apply_transformation(curve.p2, tr.base);
  curve.p3 = fastuidraw_restricted_rays_apply_transformation(curve.p3, tr.base);

  A = curve.p1 - 2.0 * curve.p2 + curve.p3;
  B = curve.p1 - curve.p2;
  C = curve.p1;

  code = fastuidraw_restricted_rays_compute_code(curve.p1.y, curve.p2.y, curve.p3.y);
  if (code != 0u)
    {
      float t1, t2, x1, x2;
      const float quad_tol = 0.0001;

      if (curve.is_quadratic && abs(A.y) > quad_tol)
        {
          float D, rA = 1.0 / A.y;

          D = B.y * B.y - A.y * C.y;

          D = sqrt(max(D, 0.0));
          t1 = (B.y - D) * rA;
          t2 = (B.y + D) * rA;
        }
      else
        {
          t1 = t2 = 0.5 * C.y / B.y;
        }

      x1 = (A.x * t1 - B.x * 2.0) * t1 + C.x;
      x2 = (A.x * t2 - B.x * 2.0) * t2 + C.x;

      if ((code & 1u) != 0u && x1 <= tr.reference_location && x1 >= 0.0)
        {
          R += 1;
        }

      if (code > 1u && x2 <= tr.reference_location && x2 >= 0.0)
        {
          R -= 1;
        }
    }

  return R;
}

void
fastuidraw_restricted_rays_apply_y_fixed_line(in vec2 p1, in vec2 p2, in vec2 p3,
                                              in bool is_curve,
                                              inout fastuidraw_restricted_rays_distance_type value)
{
  vec2 A, B, C;
  uint code;

  A = p1 - 2.0 * p2 + p3;
  B = p1 - p2;
  C = p1;

  code = fastuidraw_restricted_rays_compute_code(p1.y, p2.y, p3.y);
  if (code != 0u)
    {
      float t1, t2, x1, x2;
      vec2 p1, p2;
      const float quad_tol = 0.0001;

      if (is_curve && abs(A.y) > quad_tol)
        {
          float D, rA = 1.0 / A.y;

          D = B.y * B.y - A.y * C.y;
          if (D >= 0.0)
            {
              D = sqrt(D);
              t1 = (B.y - D) * rA;
              t2 = (B.y + D) * rA;
            }
          else
            {
              t1 = t2 = -2.0;
            }
        }
      else
        {
          t1 = t2 = 0.5 * C.y / B.y;
        }

      x1 = (A.x * t1 - B.x * 2.0) * t1 + C.x;
      x2 = (A.x * t2 - B.x * 2.0) * t2 + C.x;

      if ((code & 1u) != 0u && t1 >= 0.0 && t1 <= 1.0)
        {
          fastuidraw_restricted_rays_update_distance(abs(x1), x1 < 0.0, value);
        }

      if (code > 1u && t2 >= 0.0 && t2 <= 1.0)
        {
          fastuidraw_restricted_rays_update_distance(abs(x2), x2 > 0.0, value);
        }
    }
}

void
fastuidraw_restricted_rays_apply_endpoints(in vec2 p1, in vec2 p2, in vec2 p3,
					   in vec2 A, in vec2 B, in vec2 C,
					   inout fastuidraw_restricted_rays_distance_type value)
{
  /* We have:
   *   p(t) = (A * t - 2B) * t + C
   * so
   *   p'(t) = 2At - 2B
   * and we only care about the direction, so we drop the 2 as well.
   */
  vec2 dp1, dp3;

  dp1 = -B;
  dp3 = A - B;
  fastuidraw_restricted_rays_update_distance(p1, dp1, value);
  fastuidraw_restricted_rays_update_distance(p3, dp3, value);
}

void
fastuidraw_restricted_rays_apply_critical_points(in vec2 p1, in vec2 p2, in vec2 p3,
                                                 in vec2 A, in vec2 B, in vec2 C,
                                                 inout fastuidraw_restricted_rays_distance_type value)
{
  /* find those t for which |x'(t)| = |y'(t)|
   * which is just those t for which
   *
   *  x'(t) - y'(t) = 0 or x'(t) + y'(t) = 0
   *
   * Now,
   *
   *   p(t) = (A * t - B * 2.0) * t + C
   *
   * thus,
   *
   *   p'(t) = 2.0 * ( A * t - B)
   *
   * thus the t's are t0 and t1 where
   *
   *  (A.x * t0 - B.x) + (A.y * t0 - B.y) = 0 --> t0 = (B.x + B.y) / (A.x + A.y)
   *  (A.x * t1 - B.x) - (A.y * t1 - B.y) = 0 --> t1 = (B.x - B.y) / (A.x - A.y)
   */

  float d0, d1, n0, n1;
  const float tol = 0.0001;

  n0 = B.x + B.y;
  d0 = A.x + A.y;
  n0 *= sign(d0);
  d0 = abs(d0);

  n1 = B.x - B.y;
  d1 = A.x - A.y;
  n1 *= sign(d1);
  d1 = abs(d1);

  if (n0 > 0.0 && d0 > n0)
    {
      float t0;
      vec2 p, dp;

      t0 = n0 / d0;
      p = (A * t0 - 2.0 * B) * t0 + C;
      dp = A * t0 - B;
      fastuidraw_restricted_rays_update_distance(p, dp, value);
    }

  if (n1 > 0.0 && d1 > n1)
    {
      float t1;
      vec2 p, dp;

      t1 = n1 / d1;
      p = (A * t1 - 2.0 * B) * t1 + C;
      dp = A * t1 - B;
      fastuidraw_restricted_rays_update_distance(p, dp, value);
    }
}

vec2
fastuidraw_restricted_rays_rotate_90_degrees(vec2 v)
{
  return vec2(v.y, -v.x);
}

void
fastuidraw_restricted_rays_compute_distance(in vec2 p1, in vec2 p2, in vec2 p3,
					    in bool is_curve,
					    inout fastuidraw_restricted_rays_distance_type value)
{
  vec2 A, B, C;
  fastuidraw_restricted_rays_apply_y_fixed_line(p1, p2, p3, is_curve, value);
  fastuidraw_restricted_rays_apply_y_fixed_line(fastuidraw_restricted_rays_rotate_90_degrees(p1),
                                                fastuidraw_restricted_rays_rotate_90_degrees(p2),
                                                fastuidraw_restricted_rays_rotate_90_degrees(p3),
                                                is_curve, value);

  A = p1 - 2.0 * p2 + p3;
  B = p1 - p2;
  C = p1;
  fastuidraw_restricted_rays_apply_endpoints(p1, p2, p3, A, B, C, value);
  if (is_curve)
    {
      fastuidraw_restricted_rays_apply_critical_points(p1, p2, p3, A, B, C, value);
    }
}

void
fastuidraw_restricted_rays_load_curve(in uint raw,
                                      in uint glyph_data_location,
                                      out fastuidraw_restricted_rays_curve_type curve)
{
  uint curve_src;
  ivec2 ip1, ip2, ip3, iA, i2B, iC;

  curve_src = glyph_data_location + FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_bit0,
                                                            fastuidraw_restricted_rays_curve_num_bits,
                                                            raw);
  curve.is_quadratic = (raw & fastuidraw_restricted_rays_curve_is_quadratic_mask) != 0u;

  ip1 = fastuidraw_restricted_rays_unpack_point(curve_src);
  ip2 = fastuidraw_restricted_rays_unpack_point(curve_src + 1u);

  if (curve.is_quadratic)
    {
      ip3 = fastuidraw_restricted_rays_unpack_point(curve_src + 2u);
      curve.p2 = vec2(ip2);
    }
  else
    {
      ip3 = ip2;
      curve.p2 = 0.5 * vec2(ip1 + ip3);
    }

  curve.p1 = vec2(ip1);
  curve.p3 = vec2(ip3);
}

int
fastuidraw_restricted_rays_load_and_process_curve(in uint raw,
                                                  in uint glyph_data_location,
                                                  in fastuidraw_restricted_rays_transformation_ref tr,
                                                  inout fastuidraw_restricted_rays_distance_type nv)
{
  fastuidraw_restricted_rays_curve_type curve_data;
  int return_value;

  fastuidraw_restricted_rays_load_curve(raw,
                                        glyph_data_location,
                                        curve_data);


  return_value =
    fastuidraw_restricted_rays_compute_winding_contribution(curve_data, tr, nv);
  return return_value;
}

int
fastuidraw_restricted_rays_load_and_process_curve_hq(in uint raw,
						     in uint glyph_data_location,
						     in fastuidraw_restricted_rays_transformation_ref tr,
						     in fastuidraw_restricted_rays_transformation_frag frag_tr,
						     inout fastuidraw_restricted_rays_distance_type nv)
{
  fastuidraw_restricted_rays_curve_type curve_data;
  int return_value;

  fastuidraw_restricted_rays_load_curve(raw,
                                        glyph_data_location,
                                        curve_data);


  return_value =
    fastuidraw_restricted_rays_compute_winding_contribution_only(curve_data, tr);

  fastuidraw_restricted_rays_compute_distance(fastuidraw_restricted_rays_apply_transformation(curve_data.p1, frag_tr.base),
                                              fastuidraw_restricted_rays_apply_transformation(curve_data.p2, frag_tr.base),
                                              fastuidraw_restricted_rays_apply_transformation(curve_data.p3, frag_tr.base),
                                              curve_data.is_quadratic,
                                              nv);
  return return_value;
}

void
fastuidraw_restricted_rays_load_winding_reference(in uint location,
                                                  in fastuidraw_restricted_rays_box_type box,
                                                  out fastuidraw_restricted_rays_winding_sample_type s)
{
  uint texel, biased_winding;
  uvec2 uint_delta;
  vec2 position, delta;

  position = box.min_point;
  texel = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(location);

  biased_winding = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_winding_value_bit0,
                                           fastuidraw_restricted_rays_winding_value_num_bits, texel);
  uint_delta.x = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_position_delta_x_bit0,
                                         fastuidraw_restricted_rays_position_delta_num_bits, texel);
  uint_delta.y = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_position_delta_y_bit0,
                                         fastuidraw_restricted_rays_position_delta_num_bits, texel);

  delta = vec2(uint_delta) * box.size;
  delta /= float(fastuidraw_restricted_rays_position_delta_divide);
  position += delta;

  s.reference_position = position;
  s.reference_winding = int(biased_winding) - int(fastuidraw_restricted_rays_winding_value_bias);
}

void
fastuidraw_restricted_rays_compute_coverage_common(in uint glyph_data_location,
						   in vec2 glyph_coord,
						   in vec2 glyph_coord_dx,
						   in vec2 glyph_coord_dy,
						   in vec2 bb_box_min,
						   in vec2 bb_box_max,
						   out fastuidraw_restricted_rays_box_type texel_box,
						   out fastuidraw_restricted_rays_winding_sample_type S,
						   out int winding_number,
						   out fastuidraw_restricted_rays_distance_type nv,
						   out uint src, out uint num_curves,
						   out fastuidraw_restricted_rays_transformation_ref tr)
{
  uint curve_list, winding_sample_data_location;

  winding_sample_data_location =
    fastuidaw_restricted_rays_compute_box(glyph_coord,
                                          bb_box_min, bb_box_max,
                                          glyph_data_location,
                                          texel_box, curve_list, num_curves);
  fastuidraw_restricted_rays_init_distance(nv);
  fastuidraw_restricted_rays_load_winding_reference(winding_sample_data_location,
                                                    texel_box, S);

  winding_number = S.reference_winding;
  fastuidraw_restricted_rays_compute_transformation(glyph_coord,
						    glyph_coord_dx, glyph_coord_dy,
						    S.reference_position, tr);

  src = curve_list + glyph_data_location;
}

float
fastuidraw_restricted_rays_compute_coverage_from_dist(in int winding_number,
						      in fastuidraw_restricted_rays_distance_type nv)
{
  float cvg, distance;

  /* If the winding number at the fragment is 0, use
   * the minimum of those two; if the winding value is 1
   * use the decrement value and if the winding is -1 use the
   * increment winding number; if the absolute value of the
   * winding value is greater than two, we will view the
   * fragment as fully covered.
   */
  if (winding_number == 0)
    {
      distance = min(nv.distance_increment,
                     nv.distance_decrement);
    }
  else if (winding_number == -1)
    {
      distance = nv.distance_increment;
    }
  else if (winding_number == 1)
    {
      distance = nv.distance_decrement;
    }
  else
    {
      distance = 0.5;
    }

  distance = min(distance, 0.5);
  cvg = (winding_number != 0) ?
    (0.5 + distance) :
    (0.5 - distance);

  return cvg;
}

float
fastuidraw_restricted_rays_compute_coverage(in uint glyph_data_location,
                                            in vec2 glyph_coord,
                                            in vec2 glyph_coord_dx,
                                            in vec2 glyph_coord_dy,
                                            in vec2 bb_box_min,
                                            in vec2 bb_box_max,
                                            out fastuidraw_restricted_rays_box_type texel_box,
                                            out fastuidraw_restricted_rays_winding_sample_type S,
                                            out int winding_number, out uint num_curves,
                                            out fastuidraw_restricted_rays_distance_type nv)
{
  uint src, c, curve_list, winding_sample_data_location;
  fastuidraw_restricted_rays_transformation_ref tr;

  fastuidraw_restricted_rays_compute_coverage_common(glyph_data_location,
						     glyph_coord, glyph_coord_dx, glyph_coord_dy,
						     bb_box_min, bb_box_max,
						     texel_box, S, winding_number, nv,
						     src, num_curves, tr);
  for (c = 0u; c < num_curves; c += 2u)
    {
      uint cA, cB, curve_pair;

      curve_pair = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(src);
      ++src;

      cA = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry0_bit0,
                                   fastuidraw_restricted_rays_curve_entry_num_bits,
                                   curve_pair);
      winding_number += fastuidraw_restricted_rays_load_and_process_curve(cA, glyph_data_location, tr, nv);

      if (c + 1u < num_curves)
        {
          cB = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry1_bit0,
                                       fastuidraw_restricted_rays_curve_entry_num_bits,
                                       curve_pair);
          winding_number += fastuidraw_restricted_rays_load_and_process_curve(cB, glyph_data_location, tr, nv);
        }
    }

  return fastuidraw_restricted_rays_compute_coverage_from_dist(winding_number, nv);
}

float
fastuidraw_restricted_rays_compute_coverage_hq(in uint glyph_data_location,
					       in vec2 glyph_coord,
					       in vec2 glyph_coord_dx,
					       in vec2 glyph_coord_dy,
					       in vec2 bb_box_min,
					       in vec2 bb_box_max,
					       out fastuidraw_restricted_rays_box_type texel_box,
					       out fastuidraw_restricted_rays_winding_sample_type S,
					       out int winding_number, out uint num_curves,
					       out fastuidraw_restricted_rays_distance_type nv)
{
  uint src, c, curve_list, winding_sample_data_location;
  fastuidraw_restricted_rays_transformation_ref tr;
  fastuidraw_restricted_rays_transformation_frag frag_tr;

  fastuidraw_restricted_rays_compute_transformation_frag(glyph_coord, glyph_coord_dx, glyph_coord_dy, frag_tr);
  fastuidraw_restricted_rays_compute_coverage_common(glyph_data_location,
						     glyph_coord, glyph_coord_dx, glyph_coord_dy,
						     bb_box_min, bb_box_max,
						     texel_box, S, winding_number, nv,
						     src, num_curves, tr);
  for (c = 0u; c < num_curves; c += 2u)
    {
      uint cA, cB, curve_pair;

      curve_pair = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(src);
      ++src;

      cA = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry0_bit0,
                                   fastuidraw_restricted_rays_curve_entry_num_bits,
                                   curve_pair);
      winding_number += fastuidraw_restricted_rays_load_and_process_curve_hq(cA, glyph_data_location, tr, frag_tr, nv);

      if (c + 1u < num_curves)
        {
          cB = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry1_bit0,
                                       fastuidraw_restricted_rays_curve_entry_num_bits,
                                       curve_pair);
          winding_number += fastuidraw_restricted_rays_load_and_process_curve_hq(cB, glyph_data_location, tr, frag_tr, nv);
        }
    }

  if (frag_tr.orientation < 0.0)
    {
      fastuidraw_restricted_rays_swap_distances(nv);
    }

  return fastuidraw_restricted_rays_compute_coverage_from_dist(winding_number, nv);
}

float
fastuidraw_restricted_rays_compute_coverage_adaptive(in uint glyph_data_location,
						     in vec2 glyph_coord,
						     in vec2 glyph_coord_dx,
						     in vec2 glyph_coord_dy,
						     in vec2 bb_box_min,
						     in vec2 bb_box_max,
						     out fastuidraw_restricted_rays_box_type texel_box,
						     out fastuidraw_restricted_rays_winding_sample_type S,
						     out int winding_number, out uint num_curves,
						     out fastuidraw_restricted_rays_distance_type nv,
						     out float shearing)
{
  uint src, c, curve_list, winding_sample_data_location;
  fastuidraw_restricted_rays_transformation_ref tr;
  float fx, fy;

  fastuidraw_restricted_rays_compute_coverage_common(glyph_data_location,
						     glyph_coord, glyph_coord_dx, glyph_coord_dy,
						     bb_box_min, bb_box_max,
						     texel_box, S, winding_number, nv,
						     src, num_curves, tr);

  fx = abs(glyph_coord_dx.x) + abs(glyph_coord_dx.y);
  fy = abs(glyph_coord_dy.x) + abs(glyph_coord_dy.y);
  shearing = min(fx, fy) / max(fx, fy);

  if (shearing < 0.5f)
    {
      fastuidraw_restricted_rays_transformation_frag frag_tr;
      fastuidraw_restricted_rays_compute_transformation_frag(glyph_coord, glyph_coord_dx, glyph_coord_dy, frag_tr);
      for (c = 0u; c < num_curves; c += 2u)
	{
	  uint cA, cB, curve_pair;

	  curve_pair = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(src);
	  ++src;

	  cA = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry0_bit0,
				       fastuidraw_restricted_rays_curve_entry_num_bits,
				       curve_pair);
	  winding_number += fastuidraw_restricted_rays_load_and_process_curve_hq(cA, glyph_data_location, tr, frag_tr, nv);

	  if (c + 1u < num_curves)
	    {
	      cB = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry1_bit0,
					   fastuidraw_restricted_rays_curve_entry_num_bits,
					   curve_pair);
	      winding_number += fastuidraw_restricted_rays_load_and_process_curve_hq(cB, glyph_data_location, tr, frag_tr, nv);
	    }
	}

      if (frag_tr.orientation < 0.0)
	{
	  fastuidraw_restricted_rays_swap_distances(nv);
	}
    }
  else
    {
      for (c = 0u; c < num_curves; c += 2u)
	{
	  uint cA, cB, curve_pair;

	  curve_pair = FASTUIDRAW_RESTRICTED_RAYS_FETCH_DATA(src);
	  ++src;

	  cA = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry0_bit0,
				       fastuidraw_restricted_rays_curve_entry_num_bits,
				       curve_pair);
	  winding_number += fastuidraw_restricted_rays_load_and_process_curve(cA, glyph_data_location, tr, nv);

	  if (c + 1u < num_curves)
	    {
	      cB = FASTUIDRAW_EXTRACT_BITS(fastuidraw_restricted_rays_curve_entry1_bit0,
					   fastuidraw_restricted_rays_curve_entry_num_bits,
					   curve_pair);
	      winding_number += fastuidraw_restricted_rays_load_and_process_curve(cB, glyph_data_location, tr, nv);
	    }
	}
    }

  return fastuidraw_restricted_rays_compute_coverage_from_dist(winding_number, nv);
}

float
fastuidraw_restricted_rays_compute_coverage(in uint glyph_data_location,
                                            in vec2 glyph_coord,
                                            in vec2 glyph_coord_dx,
                                            in vec2 glyph_coord_dy,
                                            in vec2 bb_box_min,
                                            in vec2 bb_box_max)
{
  fastuidraw_restricted_rays_box_type texel_box;
  fastuidraw_restricted_rays_winding_sample_type S;
  fastuidraw_restricted_rays_distance_type nv;
  int winding_number;
  uint num_curves;

  return fastuidraw_restricted_rays_compute_coverage(glyph_data_location,
                                                     glyph_coord,
                                                     glyph_coord_dx, glyph_coord_dy,
                                                     bb_box_min, bb_box_max,
                                                     texel_box, S, winding_number, num_curves, nv);
}

float
fastuidraw_restricted_rays_compute_coverage_hq(in uint glyph_data_location,
					       in vec2 glyph_coord,
					       in vec2 glyph_coord_dx,
					       in vec2 glyph_coord_dy,
					       in vec2 bb_box_min,
					       in vec2 bb_box_max)
{
  fastuidraw_restricted_rays_box_type texel_box;
  fastuidraw_restricted_rays_winding_sample_type S;
  fastuidraw_restricted_rays_distance_type nv;
  int winding_number;
  uint num_curves;

  return fastuidraw_restricted_rays_compute_coverage_hq(glyph_data_location,
							glyph_coord,
							glyph_coord_dx, glyph_coord_dy,
							bb_box_min, bb_box_max,
							texel_box, S, winding_number, num_curves, nv);
}

float
fastuidraw_restricted_rays_compute_coverage_adaptive(in uint glyph_data_location,
						     in vec2 glyph_coord,
						     in vec2 glyph_coord_dx,
						     in vec2 glyph_coord_dy,
						     in vec2 bb_box_min,
						     in vec2 bb_box_max)
{
  fastuidraw_restricted_rays_box_type texel_box;
  fastuidraw_restricted_rays_winding_sample_type S;
  fastuidraw_restricted_rays_distance_type nv;
  float shearing;
  int winding_number;
  uint num_curves;

  return fastuidraw_restricted_rays_compute_coverage_adaptive(glyph_data_location,
							      glyph_coord,
							      glyph_coord_dx, glyph_coord_dy,
							      bb_box_min, bb_box_max,
							      texel_box, S, winding_number, num_curves, nv, shearing);
}
