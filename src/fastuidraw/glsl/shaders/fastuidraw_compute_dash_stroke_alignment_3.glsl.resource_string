float
FASTUIDRAW_COMPUTE_DASH_STROKE_HELPER(in float distance,
                                      in float distance_to_end,
                                      in float boundary0,
                                      in float boundary1)
{
  float d0, d1;
  d0 = distance - boundary0;
  d1 = boundary1 - distance;
  return (d1 <= distance_to_end) ?
    min(d0, d1) :
    d0;
}

float
FASTUIDRAW_COMPUTE_DASH_STROKE(in uint dashed_stroking_data_location,
                               in float total_distance,
                               in float first_interval_start,
                               in float in_distance,
                               in float distance_to_end_of_edge)
{
  float d, lastd, r, ff, s;
  uint loc;

  r = 0.0;
  s = 1.0;
  ff = total_distance * floor(in_distance / total_distance);
  d = in_distance - ff;
  loc = dashed_stroking_data_location;
  lastd = first_interval_start;

  /* Data is packed quite trivially, where the values are just
     the successive total lengths, so we just keep reading
     until that value is greater than d. We also have that
     the first interval is how much to draw, so the sign determines
     the distance.
   */
  do
    {
      uvec3 V;
      vec3 fV;

      V = fastuidraw_fetch_data(loc).xyz;
      fV = uintBitsToFloat(V);

      if(d < fV.x)
        {
          r = s * FASTUIDRAW_COMPUTE_DASH_STROKE_HELPER(in_distance, distance_to_end_of_edge, lastd + ff, fV.x + ff);

          //break out
          return r;
          lastd = 2.0 * total_distance + 1.0;
        }
      else if(d < fV.y)
        {
          r = -s * FASTUIDRAW_COMPUTE_DASH_STROKE_HELPER(in_distance, distance_to_end_of_edge, fV.x + ff, fV.y + ff);

          //break out
          return r;
          lastd = 2.0 * total_distance + 1.0;
        }
      else if(d < fV.z)
        {
          r = s * FASTUIDRAW_COMPUTE_DASH_STROKE_HELPER(in_distance, distance_to_end_of_edge, fV.y + ff, fV.z + ff);

          //break out
          return r;
          lastd = 2.0 * total_distance + 1.0;
        }

      s = -s;
      lastd = fV.z;
      ++loc;
    }
  while(lastd < total_distance);

  return r;
}
