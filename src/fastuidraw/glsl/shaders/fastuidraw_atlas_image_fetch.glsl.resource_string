/*!
 * \file fastuidraw_atlas_image_fetch.glsl.resource_string
 * \brief file fastuidraw_atlas_image_fetch.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@intel.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@intel.com>
 *
 */

/******************************************************************************
 * TODO:
 *   1. remove slack arguments from here, from Image, from PainterBrush
 *   2. change linear and cubic code to not worry about slack
 *        - big gain is that descision of within can be done much more easily
 *          in that we do not need to do index-tile walk to figure it out;
 *          we wil remove the fields min_delta_within_tile and max_delta_within_tile
 *   3. implement bi-cubic to work with no slack.
 *   4. make bilinear and bicubic also work with integer mipmap levels
 ******************************************************************************/

/*
 * Must have defined:
 *  - FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE: size of index tiles (must be a power of 2)
 *  - FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE: size of color tiles (must be a power of 2)
 */

/* Structure that describes the relationship between the
 * master index tile and the color tiles of an image.
 */
struct fastuidraw_image_info_type
{
  /* Number of index tile levels */
  uint num_levels;

  /* The amount to delta on the master index tile
   * to move one texel in the color tile.
   */
  float image_texel_size_on_master_index_tile;

  /* The reciprocial of image_texel_size_on_master_index_tile
   */
  float recip_image_texel_size_on_master_index_tile;
};

/* Structure to give information about what tile and where
 * within a tile an image texel is located
 */
struct fastuidraw_compute_image_atlas_coord_type
{
  /* the color-tile ID within the layer */
  uvec2 color_tile_id;

  /* the offset within the tile */
  vec2 offset_within_tile;

  /* the most negative value allowed to go in texels
   * before leaving the tile
   */
  vec2 min_delta_within_tile;

  /* the most positive value allowed to go in texels
   * before leaving the tile
   */
  vec2 max_delta_within_tile;

  /* the unnormalized texel coordinate within the color-atlas */
  vec2 unnormalized_texcoord_xy;

  /* the layer within the color atlas */
  uint layer;
};

float
fastuidraw_compute_image_size_divided_by_master_tile_size(in uint num_levels)
{
  if (num_levels >= 1)
    {
      /* Each level increases the size by a factor of FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE,
       * thus the ratio is R where R is given by
       *
       *  R = C * pow(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE, num_levels - 1)
       *
       * where
       *
       *  C = FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE
       *
       * Now,
       *
       *  R = C * pow(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE, num_levels - 1)
       *    = C * pow(2, FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE * (num_levels - 1))
       *
       * Using bitshift, we then have:
       *
       *  R = C * (1u << (FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE * (num_levels - 1)))
       */
      uint ww = uint(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE) * (num_levels - 1u);
      float index_pows = float(1u << ww);

      return float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE) * index_pows;
    }
  else
    {
      return 1.0;
    }
}

void
fastuidraw_compute_image_info(in uint num_levels,
                              out fastuidraw_image_info_type d)
{
  d.num_levels = num_levels;
  if (num_levels >= 1)
    {
      d.recip_image_texel_size_on_master_index_tile = fastuidraw_compute_image_size_divided_by_master_tile_size(num_levels);
      d.image_texel_size_on_master_index_tile = 1.0 / d.recip_image_texel_size_on_master_index_tile;
    }
  else
    {
      d.image_texel_size_on_master_index_tile = 1.0;
      d.recip_image_texel_size_on_master_index_tile = 1.0;
    }
}

/* \param image_coordinate texel coordinate within a fastuidraw::Image;
 *                         an image coordinate within a partial image
 *                         is not useful.
 * \param[out] tile_min_dist signed distance, in image texels, to min-side of tile
 * \param[out] tile_max_dist signed distance, in image texels, to max-side of tile
 */
void
fastuidraw_image_atlas_compute_tile_range(in float image_coordinate,
                                          out float tile_min_dist,
                                          out float tile_max_dist)
{
  float tile_coord;

  tile_coord = image_coordinate
    - float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE) * floor(image_coordinate * FASTUIDRAW_IMAGE_ATLAS_COLOR_RECIP_TILE_SIZE);

  tile_min_dist = -tile_coord;
  tile_max_dist = float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE) - 1.0 - tile_coord;
}

/* \param image_coord texel coordinate within a fastuidraw::Image;
 *                    an image coordinate within a partial image
 *                    is not useful.
 * \param[out] tile_min_dist signed distance, in image texels, to min-side of tile
 * \param[out] tile_max_dist signed distance, in image texels, to max-side of tile
 */
void
fastuidraw_image_atlas_compute_tile_range(in vec2 image_coord,
                                          out vec2 tile_min_dist,
                                          out vec2 tile_max_dist)
{
  fastuidraw_image_atlas_compute_tile_range(image_coord.x, tile_min_dist.x, tile_max_dist.x);
  fastuidraw_image_atlas_compute_tile_range(image_coord.y, tile_min_dist.y, tile_max_dist.y);
}

/* \param master_tile_texel_coord unnormalized texel coordinate of within the master-index tile
 * \param index_layer what layer from the index-atlas the master tile is located at
 * \param num_levels number of index levels needed to reach the color-tile
 */
void
fastuidraw_compute_image_atlas_coord(in vec2 master_tile_texel_coord,
                                     in uint index_layer,
                                     in uint num_levels,
                                     out fastuidraw_compute_image_atlas_coord_type return_value)
{
  uvec4 tile_id;
  vec2 color_atlas_texcoord_xy;
  ivec2 itexel_coordinate;

  itexel_coordinate = ivec2(master_tile_texel_coord);
  tile_id = texelFetch(fastuidraw_imageIndexAtlas,
                       ivec3(itexel_coordinate, index_layer),
                       0);
  index_layer = tile_id.z + 256u * tile_id.w;

  for(uint i = 1u; i < num_levels; ++i)
    {
      vec2 index_tile_offset;
      vec2 texel_coordinate;

      master_tile_texel_coord -= vec2(itexel_coordinate);
      index_tile_offset = master_tile_texel_coord * float(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE);
      texel_coordinate = index_tile_offset
        + vec2(tile_id.xy) * float(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE);

      itexel_coordinate = ivec2(texel_coordinate);
      tile_id = texelFetch(fastuidraw_imageIndexAtlas,
                           ivec3(itexel_coordinate, index_layer),
                           0);
      index_layer = tile_id.z + 256u * tile_id.w;

      master_tile_texel_coord = texel_coordinate;
    }

  /* at this point index_layer gives the layer into colorAtlas
   * and tile_id gives which tile in the color atlas
   */
  vec2 tile_offset;
  uint subtile_image_size;

  subtile_image_size = uint(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE);
  tile_offset = (master_tile_texel_coord - vec2(itexel_coordinate)) * float(subtile_image_size);

  return_value.color_tile_id = tile_id.xy;
  return_value.offset_within_tile = tile_offset;
  return_value.unnormalized_texcoord_xy = tile_offset //offset into tile
    + vec2(tile_id.xy) * float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE); //location of tile

  return_value.min_delta_within_tile = -tile_offset;

  return_value.max_delta_within_tile =
    vec2(float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE - 1)) - tile_offset;

  return_value.layer = index_layer;
}

void
fastuidraw_compute_image_atlas_coord(in vec2 master_tile_texel_coord,
                                     in uint index_layer,
                                     in uint num_levels,
                                     out vec2 return_value_unnormalized_texcoord_xy,
                                     out uint return_value_layer)
{
  fastuidraw_compute_image_atlas_coord_type str;

  fastuidraw_compute_image_atlas_coord(master_tile_texel_coord,
                                       index_layer,
                                       num_levels,
                                       str);
  return_value_unnormalized_texcoord_xy = str.unnormalized_texcoord_xy;
  return_value_layer = str.layer;
}

vec4
fastuidraw_nearest_filter_atlas_image(in vec2 master_tile_texel_coord,
                                      in uint index_layer,
                                      in uint num_levels,
                                      in float index_texel_coord_delta,
                                      in float lod)
{
  fastuidraw_compute_image_atlas_coord_type atlas_location;

  fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                       num_levels, atlas_location);

  return textureLod(fastuidraw_imageAtlasNearest,
                    vec3(atlas_location.unnormalized_texcoord_xy * fastuidraw_imageAtlasLinear_size_reciprocal,
                         atlas_location.layer),
                    lod);
}

/* \param master_tile_texel_coord unnormalized texel coordinate of within the master-index tile
 * \param index_layer what layer from the index-atlas the master tile is located at
 * \param num_levels number of index levels needed to reach the color-tile
 * \param index_texel_coord_delta gives the delta to move in the master index tile to
 *                                get to the next texel in the color tile.
 */
vec4
fastuidraw_linear_filter_atlas_image(in vec2 master_tile_texel_coord,
                                     in uint index_layer,
                                     in uint num_levels,
                                     in float index_texel_coord_delta,
                                     in float lod)
{
  vec4 image_color;
  vec2 min_tile_dist, max_tile_dist;
  fastuidraw_compute_image_atlas_coord_type vanilla_atlas_location;

  /* TODO: the work to handle LOD non-zero correctly. */
  lod = 0.0;

  fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                       num_levels, vanilla_atlas_location);

  if (vanilla_atlas_location.max_delta_within_tile.x >= 0.5
      && vanilla_atlas_location.max_delta_within_tile.y >= 0.5
      && vanilla_atlas_location.min_delta_within_tile.x <= -0.5
      && vanilla_atlas_location.min_delta_within_tile.y <= -0.5)
    {
      image_color = textureLod(fastuidraw_imageAtlasLinear,
                               vec3(vanilla_atlas_location.unnormalized_texcoord_xy * fastuidraw_imageAtlasLinear_size_reciprocal,
                                    vanilla_atlas_location.layer),
                               lod);
    }
  else
    {
      /* Sighs, we need to do the bilinear filter ourselves because
       * atleas one of the neighboring texels is in a different tile.
       */
      ivec3 t00, t10, t01, t11;
      fastuidraw_compute_image_atlas_coord_type atlas_location_t00;

      /* Ick. We cannot assume the texel named by atlas_location is the
       * bottom-left texel to use in bilinear filtering. It is the left side
       * is the fractional part of the texel coordinate is <= 0.5 and
       * same story as bottom-side. To avoid the drama of doing the right
       * thing, we instead will do the atlas-computation over.
       */
      master_tile_texel_coord -= vec2(0.5 * index_texel_coord_delta);
      fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                           num_levels, atlas_location_t00);

      t00 = ivec3(atlas_location_t00.unnormalized_texcoord_xy, atlas_location_t00.layer);
      if (atlas_location_t00.max_delta_within_tile.x >= 1)
        {
          t10.yz = t00.yz;
          t10.x = t00.x + 1;
        }
      else
        {
          fastuidraw_compute_image_atlas_coord_type atlas_location_t10;
          vec2 master_tile_texel_coord_nxt = master_tile_texel_coord + vec2(index_texel_coord_delta, 0.0);

          fastuidraw_compute_image_atlas_coord(master_tile_texel_coord_nxt, index_layer,
                                               num_levels, atlas_location_t10);
          t10 = ivec3(atlas_location_t10.unnormalized_texcoord_xy,
                      atlas_location_t10.layer);
        }

      if (atlas_location_t00.max_delta_within_tile.y >= 1)
        {
          t01.xz = t00.xz;
          t01.y = t00.y + 1;

          t11.xz = t10.xz;
          t11.y = t10.y + 1;
        }
      else
        {
          fastuidraw_compute_image_atlas_coord_type atlas_location_t01;
          vec2 master_tile_texel_coord_nxt = master_tile_texel_coord + vec2(0.0, index_texel_coord_delta);

          fastuidraw_compute_image_atlas_coord(master_tile_texel_coord_nxt,
                                               index_layer, num_levels,
                                               atlas_location_t01);
          t01 = ivec3(atlas_location_t01.unnormalized_texcoord_xy,
                      atlas_location_t01.layer);

          if (atlas_location_t00.max_delta_within_tile.x >= 1)
            {
              t11.x = t01.x + 1;
              t11.yz = t01.yz;
            }
          else
            {
              fastuidraw_compute_image_atlas_coord_type atlas_location_t11;
              vec2 master_tile_texel_coord_nxt = master_tile_texel_coord + vec2(index_texel_coord_delta);

              fastuidraw_compute_image_atlas_coord(master_tile_texel_coord_nxt,
                                                   index_layer, num_levels,
                                                   atlas_location_t11);
              t11 = ivec3(atlas_location_t11.unnormalized_texcoord_xy,
                          atlas_location_t11.layer);
            }
        }

      vec4 c00, c10, c01, c11, c0, c1;

      c00 = texelFetch(fastuidraw_imageAtlasLinear, t00, 0);
      c01 = texelFetch(fastuidraw_imageAtlasLinear, t01, 0);
      c10 = texelFetch(fastuidraw_imageAtlasLinear, t10, 0);
      c11 = texelFetch(fastuidraw_imageAtlasLinear, t11, 0);

      c0 = mix(c00, c01, fract(atlas_location_t00.unnormalized_texcoord_xy.y));
      c1 = mix(c10, c11, fract(atlas_location_t00.unnormalized_texcoord_xy.y));

      image_color = mix(c0, c1, fract(atlas_location_t00.unnormalized_texcoord_xy.x));
    }
  return image_color;
}

vec4
fastuidraw_image_cubic_weights(float x)
{
    float x_squared = x * x;
    float x_cubed = x_squared * x;
    float one_minus_x = 1.0 - x;
    float one_minus_x_squared = one_minus_x * one_minus_x;
    float one_minus_x_cubed = one_minus_x_squared  * one_minus_x;
    vec4 w;

    w.x = one_minus_x_cubed;
    w.y = 3.0 * x_cubed - 6.0 * x_squared + 4.0;
    w.z = 3.0 * one_minus_x_cubed - 6.0 * one_minus_x_squared + 4.0;
    w.w = x_cubed;
    return w / 6.0;
}

/* \param master_tile_texel_coord unnormalized texel coordinate of within the master-index tile
 * \param index_layer what layer from the index-atlas the master tile is located at
 * \param num_levels number of index levels needed to reach the color-tile
 * \param index_texel_coord_delta gives the delta to move in the master index tile to
 *                                get to the next texel in the color tile.
 * \param atlas_location the output of fastuidraw_compute_image_atlas_coord() when passed
 *                       master_tile_texel_coord, index_layer, num_levels, slack
 */
vec4
fastuidraw_cubic_filter_atlas_image(in vec2 master_tile_texel_coord,
                                    in uint index_layer,
                                    in uint num_levels,
                                    in float index_texel_coord_delta,
                                    in float lod)
{
  vec4 image_color;
  fastuidraw_compute_image_atlas_coord_type atlas_location;

  /* TODO: the work to handle LOD non-zero correctly. */
  lod = 0.0;

  fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                       num_levels, atlas_location);

  /* Cubic filtering by realizing cubic-filtering as repeated
   * bilinear filtering, see GPU Gems 2, Chapter 20.
   * Code inspired by StackOverflow (http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl)
   * and from Shiny Pixels (http://vec3.ca/bicubic-filtering-in-fewer-taps/)
   */
  vec2 fract_texel_coord, linear_weight, texel_coord;
  vec4 x_weights, y_weights;
  vec4 corner_coords, weight_sums, texture_coords;
  vec4 t00, t10, t01, t11;

  /* TODO: handle if we need to walk outside of the tile */

  texel_coord = atlas_location.unnormalized_texcoord_xy - vec2(0.5, 0.5);
  fract_texel_coord = fract(texel_coord);
  texel_coord -= fract_texel_coord;

  x_weights = fastuidraw_image_cubic_weights(fract_texel_coord.x);
  y_weights = fastuidraw_image_cubic_weights(fract_texel_coord.y);

  corner_coords = vec4(texel_coord.x - 0.5, texel_coord.x + 1.5,
                       texel_coord.y - 0.5, texel_coord.y + 1.5);
  weight_sums = vec4(x_weights.x + x_weights.y, x_weights.z + x_weights.w,
                     y_weights.x + y_weights.y, y_weights.z + y_weights.w);

  texture_coords = corner_coords + vec4(x_weights.y, x_weights.w, y_weights.y, y_weights.w) / weight_sums;
  texture_coords *= fastuidraw_imageAtlasLinear_size_reciprocal.xyxy;

  t00 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.xz, atlas_location.layer), 0.0);
  t10 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.yz, atlas_location.layer), 0.0);
  t01 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.xw, atlas_location.layer), 0.0);
  t11 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.yw, atlas_location.layer), 0.0);

  linear_weight.x = weight_sums.y / (weight_sums.x + weight_sums.y);
  linear_weight.y = weight_sums.w / (weight_sums.z + weight_sums.w);

  return mix(mix(t00, t10, linear_weight.x),
             mix(t01, t11, linear_weight.x),
             linear_weight.y);
}
