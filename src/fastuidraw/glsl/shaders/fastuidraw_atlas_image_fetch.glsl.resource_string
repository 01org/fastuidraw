/*!
 * \file fastuidraw_atlas_image_fetch.glsl.resource_string
 * \brief file fastuidraw_atlas_image_fetch.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@intel.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@intel.com>
 *
 */


/*
 * Must have defined:
 *  - FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE: size of index tiles (must be a power of 2)
 *  - FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE: size of color tiles (must be a power of 2)
 */

struct fastuidraw_compute_image_atlas_coord_type
{
  /* the color-tile ID within the layer */
  uvec2 color_tile_id;

  /* the offset within the tile */
  vec2 offset_within_tile;

  /* the most negative value allowed to go in texels
   * before leaving the tile
   */
  vec2 min_delta_within_tile;

  /* the most positive value allowed to go in texels
   * before leaving the tile
   */
  vec2 max_delta_within_tile;

  /* the unnormalized texel coordinate within the color-atlas */
  vec2 unnormalized_texcoord_xy;

  /* the layer within the color atlas */
  uint layer;
};

uint
fastuidraw_compute_image_size_divided_by_master_tile_size(in uint pnum_levels, in uint slack)
{
  if (pnum_levels >= 1)
    {
      /* Each level increases the size by a factor of FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE,
       * thus the ratio is R where R is given by
       *
       *  R = C * pow(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE, pnum_levels - 1)
       *
       * where
       *
       *  C = (FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE - 2 * slack)
       *
       * Now,
       *
       *  R = C * pow(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE, pnum_levels - 1)
       *    = C * pow(2, FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE * (pnum_levels - 1))
       *
       * Using bitshift, we then have:
       *
       *  R = C * (1u << (FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE * (pnum_levels - 1)))
       */
      uint ww = uint(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE) * (pnum_levels - 1u);
      uint index_pows = (1u << ww);
      return (uint(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE) - 2u * slack) * index_pows;
    }
  else
    {
      return 1u;
    }
}

/* \param master_index_texel_coord unnormalized texel coordinate of within the master-index tile
 * \param index_layer what layer from the index-atlas the master tile is located at
 * \param num_levels number of index levels needed to reach the color-tile
 * \param slack the amount of repeat data on the boundary of each color tile
 */
void
fastuidraw_compute_image_atlas_coord(in vec2 master_index_texel_coord,
                                     in uint index_layer,
                                     in uint num_levels,
                                     in uint slack,
                                     out fastuidraw_compute_image_atlas_coord_type return_value)
{
  uvec4 tile_id;
  vec2 color_atlas_texcoord_xy;
  ivec2 itexel_coordinate;

  itexel_coordinate = ivec2(master_index_texel_coord);
  tile_id = texelFetch(fastuidraw_imageIndexAtlas,
                       ivec3(itexel_coordinate, index_layer),
                       0);
  index_layer = tile_id.z + 256u * tile_id.w;

  for(uint i = 1u; i < num_levels; ++i)
    {
      vec2 index_tile_offset;
      vec2 texel_coordinate;

      master_index_texel_coord -= vec2(itexel_coordinate);
      index_tile_offset = master_index_texel_coord * float(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE);
      texel_coordinate = index_tile_offset
        + vec2(tile_id.xy) * float(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE);

      itexel_coordinate = ivec2(texel_coordinate);
      tile_id = texelFetch(fastuidraw_imageIndexAtlas,
                           ivec3(itexel_coordinate, index_layer),
                           0);
      index_layer = tile_id.z + 256u * tile_id.w;

      master_index_texel_coord = texel_coordinate;
    }

  /* at this point index_layer gives the layer into colorAtlas
   * and tile_id gives which tile in the color atlas
   */
  vec2 tile_offset;
  uint subtile_image_size;

  subtile_image_size = uint(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE);
  subtile_image_size -= 2u * slack;
  tile_offset = (master_index_texel_coord - vec2(itexel_coordinate)) * float(subtile_image_size);

  return_value.color_tile_id = tile_id.xy;
  return_value.offset_within_tile = tile_offset;
  return_value.unnormalized_texcoord_xy = tile_offset //offset into tile
    + vec2(float(slack)) //slack added
    + vec2(tile_id.xy) * float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE); //location of tile

  return_value.min_delta_within_tile =
    -vec2(float(slack)) - tile_offset;

  return_value.max_delta_within_tile =
    vec2(float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE + slack - 1)) - tile_offset;

  return_value.layer = index_layer;
}

void
fastuidraw_compute_image_atlas_coord(in vec2 master_index_texel_coord,
                                     in uint index_layer,
                                     in uint num_levels,
                                     in uint slack,
                                     out vec2 return_value_unnormalized_texcoord_xy,
                                     out uint return_value_layer)
{
  fastuidraw_compute_image_atlas_coord_type str;

  fastuidraw_compute_image_atlas_coord(master_index_texel_coord,
                                 index_layer,
                                 num_levels,
                                 slack,
                                 str);
  return_value_unnormalized_texcoord_xy = str.unnormalized_texcoord_xy;
  return_value_layer = str.layer;
}

/* computes from an image-coordinate the range allowed to stay within
 * the same tile
 */
void
fastuidraw_compute_range_within_tile(in uint image_coord,
                                     out uint min_within_tile,
                                     out uint max_within_tile)
{
  uint tile_offset;

  tile_offset = image_coord & (FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE - 1);
  min_within_tile = image_coord - tile_offset;
  max_within_tile = image_coord + (FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE - 1 - tile_offset);
}
