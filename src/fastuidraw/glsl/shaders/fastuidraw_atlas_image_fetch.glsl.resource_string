/*!
 * \file fastuidraw_atlas_image_fetch.glsl.resource_string
 * \brief file fastuidraw_atlas_image_fetch.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@intel.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@intel.com>
 *
 */

/*
 * Must have defined:
 *  - FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE: size of index tiles (must be a power of 2)
 *  - FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE: size of color tiles (must be a power of 2)
 */

/* Structure that describes the relationship between the
 * master index tile and the color tiles of an image.
 */
struct fastuidraw_image_info_type
{
  /* Number of index tile levels */
  uint num_levels;

  /* The amount to delta on the master index tile
   * to move one texel in the color tile.
   */
  float image_texel_size_on_master_index_tile;

  /* The reciprocial of image_texel_size_on_master_index_tile
   */
  float recip_image_texel_size_on_master_index_tile;
};

/* Structure to give information about what tile and where
 * within a tile an image texel is located
 */
struct fastuidraw_compute_image_atlas_coord_type
{
  /* the color-tile ID within the layer */
  uvec2 color_tile_id;

  /* the offset within the tile */
  vec2 offset_within_tile;

  /* the most negative value allowed to go in texels
   * before leaving the tile
   */
  vec2 min_delta_within_tile;

  /* the most positive value allowed to go in texels
   * before leaving the tile
   */
  vec2 max_delta_within_tile;

  /* the unnormalized texel coordinate within the color-atlas */
  vec2 unnormalized_texcoord_xy;

  /* the layer within the color atlas */
  uint layer;
};

void
fastuidraw_compute_image_info(in uint num_levels,
                              out fastuidraw_image_info_type d)
{
  d.num_levels = num_levels;
  if (num_levels >= 1u)
    {/* Each level increases the size by a factor of FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE,
       * thus the ratio is R where R is given by
       *
       *  R = C * pow(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE, num_levels - 1)
       *
       * where
       *
       *  C = FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE
       *
       * Now,
       *
       *  R = C * pow(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE, num_levels - 1)
       *    = C * pow(2, FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE * (num_levels - 1))
       *
       * Using bitshift, we then have:
       *
       *  R = C * (1u << (FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE * (num_levels - 1)))
       */
      uint ww = uint(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_LOG2_SIZE) * (num_levels - 1u);
      float index_pows = float(1u << ww);

      d.recip_image_texel_size_on_master_index_tile = float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE) * index_pows;
      d.image_texel_size_on_master_index_tile = 1.0 / d.recip_image_texel_size_on_master_index_tile;
    }
  else
    {
      d.image_texel_size_on_master_index_tile = 1.0;
      d.recip_image_texel_size_on_master_index_tile = 1.0;
    }
}

/* \param image_coordinate texel coordinate within a fastuidraw::Image;
 *                         an image coordinate within a partial image
 *                         is not useful.
 * \param[out] tile_min_dist signed distance, in image texels, to min-side of tile
 * \param[out] tile_max_dist signed distance, in image texels, to max-side of tile
 */
void
fastuidraw_image_atlas_compute_tile_range(in float image_coordinate,
                                          out float tile_min_dist,
                                          out float tile_max_dist)
{
  float tile_coord;

  tile_coord = image_coordinate
    - float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE) * floor(image_coordinate * FASTUIDRAW_IMAGE_ATLAS_COLOR_RECIP_TILE_SIZE);

  tile_min_dist = -tile_coord;
  tile_max_dist = float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE) - 1.0 - tile_coord;
}

/* \param image_coord texel coordinate within a fastuidraw::Image;
 *                    an image coordinate within a partial image
 *                    is not useful.
 * \param[out] tile_min_dist signed distance, in image texels, to min-side of tile
 * \param[out] tile_max_dist signed distance, in image texels, to max-side of tile
 */
void
fastuidraw_image_atlas_compute_tile_range(in vec2 image_coord,
                                          out vec2 tile_min_dist,
                                          out vec2 tile_max_dist)
{
  fastuidraw_image_atlas_compute_tile_range(image_coord.x, tile_min_dist.x, tile_max_dist.x);
  fastuidraw_image_atlas_compute_tile_range(image_coord.y, tile_min_dist.y, tile_max_dist.y);
}

/* Compute the image coordinate from the master-tile texture coordinate */
float
fastuidraw_compute_image_coordinate(in float master_tile_tex_coord,
                                    in fastuidraw_image_info_type image_info)
{
  float relative;

  /* The master index tile ALWAYS starts at a multiple of
   * FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE, so the value of
   * mod(master_tile_tex_coord, FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE)
   * gives the relative coordinate within the tile. To avoid
   * the expensive divide, we use FASTUIDRAW_IMAGE_ATLAS_INDEX_RECIP_TILE_SIZE
   * together with floor.
   */
  relative = master_tile_tex_coord
    - float(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE) * floor(FASTUIDRAW_IMAGE_ATLAS_INDEX_RECIP_TILE_SIZE * master_tile_tex_coord);

  /* The image coordinate is then given by the relative value times
   * the size ratio of the color-tile to master-tile
   */
  return relative * image_info.recip_image_texel_size_on_master_index_tile;
}

vec2
fastuidraw_compute_image_coordinate(in vec2 master_tile_tex_coord,
                                    in fastuidraw_image_info_type image_info)
{
  return vec2(fastuidraw_compute_image_coordinate(master_tile_tex_coord.x,
                                                  image_info),
              fastuidraw_compute_image_coordinate(master_tile_tex_coord.y,
                                                  image_info));
}

/* \param master_tile_texel_coord unnormalized texel coordinate of within the master-index tile
 * \param index_layer what layer from the index-atlas the master tile is located at
 * \param num_levels number of index levels needed to reach the color-tile
 */
void
fastuidraw_compute_image_atlas_coord(in vec2 master_tile_texel_coord,
                                     in uint index_layer,
                                     in uint num_levels,
                                     out fastuidraw_compute_image_atlas_coord_type return_value)
{
  uvec4 tile_id;
  vec2 color_atlas_texcoord_xy;
  ivec2 itexel_coordinate;

  itexel_coordinate = ivec2(master_tile_texel_coord);
  tile_id = texelFetch(fastuidraw_imageIndexAtlas,
                       ivec3(itexel_coordinate, index_layer),
                       0);
  index_layer = tile_id.z + 256u * tile_id.w;

  for(uint i = 1u; i < num_levels; ++i)
    {
      vec2 index_tile_offset;
      vec2 texel_coordinate;

      master_tile_texel_coord -= vec2(itexel_coordinate);
      index_tile_offset = master_tile_texel_coord * float(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE);
      texel_coordinate = index_tile_offset
        + vec2(tile_id.xy) * float(FASTUIDRAW_IMAGE_ATLAS_INDEX_TILE_SIZE);

      itexel_coordinate = ivec2(texel_coordinate);
      tile_id = texelFetch(fastuidraw_imageIndexAtlas,
                           ivec3(itexel_coordinate, index_layer),
                           0);
      index_layer = tile_id.z + 256u * tile_id.w;

      master_tile_texel_coord = texel_coordinate;
    }

  /* at this point index_layer gives the layer into colorAtlas
   * and tile_id gives which tile in the color atlas
   */
  vec2 tile_offset;
  uint subtile_image_size;

  subtile_image_size = uint(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE);
  tile_offset = (master_tile_texel_coord - vec2(itexel_coordinate)) * float(subtile_image_size);

  return_value.color_tile_id = tile_id.xy;
  return_value.offset_within_tile = tile_offset;
  return_value.unnormalized_texcoord_xy = tile_offset //offset into tile
    + vec2(tile_id.xy) * float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE); //location of tile

  return_value.min_delta_within_tile = -tile_offset;

  return_value.max_delta_within_tile =
    vec2(float(FASTUIDRAW_IMAGE_ATLAS_COLOR_TILE_SIZE - 1u)) - tile_offset;

  return_value.layer = index_layer;
}

vec4
fastuidraw_nearest_filter_atlas_image(in vec2 master_tile_texel_coord,
                                      in uint index_layer,
                                      in uint num_levels,
                                      in float lod)
{
  fastuidraw_compute_image_atlas_coord_type atlas_location;

  fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                       num_levels, atlas_location);

  return textureLod(fastuidraw_imageAtlasNearest,
                    vec3(atlas_location.unnormalized_texcoord_xy * fastuidraw_imageAtlasLinear_size_reciprocal,
                         atlas_location.layer),
                    lod);
}

/* \param master_tile_texel_coord unnormalized texel coordinate of within the master-index tile
 * \param index_layer what layer from the index-atlas the master tile is located at
 * \param num_levels number of index levels needed to reach the color-tile
 * \param index_texel_coord_delta gives the delta to move in the master index tile to
 *                                get to the next texel in the color tile.
 */
vec4
fastuidraw_linear_filter_atlas_image(in vec2 master_tile_texel_coord,
                                     in uint index_layer,
                                     in fastuidraw_image_info_type image_info,
                                     in float lod)
{
  vec4 image_color;
  vec2 image_coordinate, min_tile_dist, max_tile_dist;
  int lod_i;
  float lod_factor, half_lod_factor;

  lod_i = int(lod);
  lod = float(lod_i);
  lod_factor = float(1 << lod_i);
  half_lod_factor = 0.5 * lod_factor;

  image_coordinate = fastuidraw_compute_image_coordinate(master_tile_texel_coord, image_info);
  fastuidraw_image_atlas_compute_tile_range(image_coordinate, min_tile_dist, max_tile_dist);

  if (max_tile_dist.x >= half_lod_factor
      && max_tile_dist.y >= half_lod_factor
      && min_tile_dist.x <= -half_lod_factor
      && min_tile_dist.y <= -half_lod_factor)
    {
      fastuidraw_compute_image_atlas_coord_type atlas_location;

      fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                           image_info.num_levels, atlas_location);
      image_color = textureLod(fastuidraw_imageAtlasLinear,
                               vec3(atlas_location.unnormalized_texcoord_xy * fastuidraw_imageAtlasLinear_size_reciprocal,
                                    atlas_location.layer),
                               lod);
    }
  else
    {
      /* Sighs, we need to do the bilinear filter ourselves because
       * atleas one of the neighboring texels is in a different tile.
       */
      ivec3 t00, t10, t01, t11;
      fastuidraw_compute_image_atlas_coord_type atlas_location_t00;
      float inverse_lod_factor, next_pixel_delta;

      inverse_lod_factor = 1.0f / lod_factor;
      next_pixel_delta = lod_factor * image_info.image_texel_size_on_master_index_tile;

      /* we want the texel that is half a pixel to the left/down
       * of the input location.
       */
      master_tile_texel_coord -= vec2(0.5 * next_pixel_delta);
      fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                           image_info.num_levels, atlas_location_t00);

      t00 = ivec3(atlas_location_t00.unnormalized_texcoord_xy * inverse_lod_factor, atlas_location_t00.layer);
      if (atlas_location_t00.max_delta_within_tile.x >= lod_factor)
        {
          t10.yz = t00.yz;
          t10.x = t00.x + 1;
        }
      else
        {
          fastuidraw_compute_image_atlas_coord_type atlas_location_t10;
          vec2 master_tile_texel_coord_nxt = master_tile_texel_coord + vec2(next_pixel_delta, 0.0);

          fastuidraw_compute_image_atlas_coord(master_tile_texel_coord_nxt, index_layer,
                                               image_info.num_levels, atlas_location_t10);
          t10 = ivec3(atlas_location_t10.unnormalized_texcoord_xy * inverse_lod_factor,
                      atlas_location_t10.layer);
        }

      if (atlas_location_t00.max_delta_within_tile.y >= lod_factor)
        {
          t01.xz = t00.xz;
          t01.y = t00.y + 1;

          t11.xz = t10.xz;
          t11.y = t10.y + 1;
        }
      else
        {
          fastuidraw_compute_image_atlas_coord_type atlas_location_t01;
          vec2 master_tile_texel_coord_nxt = master_tile_texel_coord + vec2(0.0, next_pixel_delta);

          fastuidraw_compute_image_atlas_coord(master_tile_texel_coord_nxt,
                                               index_layer, image_info.num_levels,
                                               atlas_location_t01);
          t01 = ivec3(atlas_location_t01.unnormalized_texcoord_xy * inverse_lod_factor,
                      atlas_location_t01.layer);

          if (atlas_location_t00.max_delta_within_tile.x >= lod_factor)
            {
              t11.x = t01.x + 1;
              t11.yz = t01.yz;
            }
          else
            {
              fastuidraw_compute_image_atlas_coord_type atlas_location_t11;
              vec2 master_tile_texel_coord_nxt = master_tile_texel_coord + vec2(next_pixel_delta);

              fastuidraw_compute_image_atlas_coord(master_tile_texel_coord_nxt,
                                                   index_layer, image_info.num_levels,
                                                   atlas_location_t11);
              t11 = ivec3(atlas_location_t11.unnormalized_texcoord_xy * inverse_lod_factor,
                          atlas_location_t11.layer);
            }
        }

      vec4 c00, c10, c01, c11, c0, c1;

      c00 = texelFetch(fastuidraw_imageAtlasLinear, t00, lod_i);
      c01 = texelFetch(fastuidraw_imageAtlasLinear, t01, lod_i);
      c10 = texelFetch(fastuidraw_imageAtlasLinear, t10, lod_i);
      c11 = texelFetch(fastuidraw_imageAtlasLinear, t11, lod_i);

      c0 = mix(c00, c01, fract(inverse_lod_factor * atlas_location_t00.unnormalized_texcoord_xy.y));
      c1 = mix(c10, c11, fract(inverse_lod_factor * atlas_location_t00.unnormalized_texcoord_xy.y));

      image_color = mix(c0, c1, fract(inverse_lod_factor * atlas_location_t00.unnormalized_texcoord_xy.x));
    }
  return image_color;
}

vec4
fastuidraw_image_cubic_weights(float x)
{
    float x_squared = x * x;
    float x_cubed = x_squared * x;
    float one_minus_x = 1.0 - x;
    float one_minus_x_squared = one_minus_x * one_minus_x;
    float one_minus_x_cubed = one_minus_x_squared  * one_minus_x;
    vec4 w;

    w.x = one_minus_x_cubed;
    w.y = 3.0 * x_cubed - 6.0 * x_squared + 4.0;
    w.z = 3.0 * one_minus_x_cubed - 6.0 * one_minus_x_squared + 4.0;
    w.w = x_cubed;
    return w / 6.0;
}

/* \param master_tile_texel_coord unnormalized texel coordinate of within the master-index tile
 * \param index_layer what layer from the index-atlas the master tile is located at
 * \param num_levels number of index levels needed to reach the color-tile
 * \param index_texel_coord_delta gives the delta to move in the master index tile to
 *                                get to the next texel in the color tile.
 * \param atlas_location the output of fastuidraw_compute_image_atlas_coord() when passed
 *                       master_tile_texel_coord, index_layer, num_levels, slack
 */
vec4
fastuidraw_cubic_filter_atlas_image(in vec2 in_master_tile_texel_coord,
                                    in uint index_layer,
                                    in fastuidraw_image_info_type image_info,
                                    in float lod)
{
  vec4 image_color;
  vec2 master_tile_texel_coord;
  vec2 image_coordinate, fract_image_coordinate;
  vec2 min_tile_dist, max_tile_dist, linear_weight;
  vec4 x_weights, y_weights, weight_sums, recip_weight_sums;
  vec4 t00, t10, t01, t11;

  /* TODO: the work to handle LOD non-zero correctly. */
  lod = 0.0;

  /* slide the input coordinate by 0.5 image texels to the left/bottom */
  master_tile_texel_coord = in_master_tile_texel_coord - 0.5 * vec2(image_info.image_texel_size_on_master_index_tile);

  image_coordinate = fastuidraw_compute_image_coordinate(master_tile_texel_coord, image_info);
  fastuidraw_image_atlas_compute_tile_range(image_coordinate, min_tile_dist, max_tile_dist);

  fract_image_coordinate = fract(image_coordinate);
  image_coordinate -= fract_image_coordinate;

  x_weights = fastuidraw_image_cubic_weights(fract_image_coordinate.x);
  y_weights = fastuidraw_image_cubic_weights(fract_image_coordinate.y);
  weight_sums = vec4(x_weights.x + x_weights.y, x_weights.z + x_weights.w,
                     y_weights.x + y_weights.y, y_weights.z + y_weights.w);
  recip_weight_sums = vec4(1.0) / weight_sums;

  linear_weight.x = weight_sums.y / (weight_sums.x + weight_sums.y);
  linear_weight.y = weight_sums.w / (weight_sums.z + weight_sums.w);

  if (min_tile_dist.x <= -1.5
      && min_tile_dist.y <= -1.5
      && max_tile_dist.x >= 2.5
      && max_tile_dist.y >= 2.5)
    {
      fastuidraw_compute_image_atlas_coord_type atlas_location;
      fastuidraw_compute_image_atlas_coord(master_tile_texel_coord, index_layer,
                                           image_info.num_levels, atlas_location);

      /* Cubic filtering by realizing cubic-filtering as repeated
       * bilinear filtering, see GPU Gems 2, Chapter 20.
       * Code inspired by StackOverflow (http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl)
       * and from Shiny Pixels (http://vec3.ca/bicubic-filtering-in-fewer-taps/)
       */
      vec2 texel_coord;
      vec4 corner_coords, texture_coords;

      texel_coord = atlas_location.unnormalized_texcoord_xy;
      texel_coord -= fract_image_coordinate;

      corner_coords = texel_coord.xxyy;
      corner_coords.xz -= vec2(0.5);
      corner_coords.yw += vec2(1.5);

      texture_coords = corner_coords + vec4(x_weights.y, x_weights.w, y_weights.y, y_weights.w) * recip_weight_sums;
      texture_coords *= fastuidraw_imageAtlasLinear_size_reciprocal.xyxy;

      t00 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.xz, atlas_location.layer), lod);
      t10 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.yz, atlas_location.layer), lod);
      t01 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.xw, atlas_location.layer), lod);
      t11 = textureLod(fastuidraw_imageAtlasLinear, vec3(texture_coords.yw, atlas_location.layer), lod);
    }
  else
    {
      vec2 master_texel_coord;
      vec4 corner_coords, offset_coords, master_coords;

      master_texel_coord = master_tile_texel_coord;
      master_texel_coord -= fract_image_coordinate * vec2(image_info.image_texel_size_on_master_index_tile);

      corner_coords = master_texel_coord.xxyy;
      corner_coords.xz -= vec2(0.5 * image_info.image_texel_size_on_master_index_tile);
      corner_coords.yw += vec2(1.5 * image_info.image_texel_size_on_master_index_tile);

      offset_coords = vec4(x_weights.y, x_weights.w, y_weights.y, y_weights.w) * recip_weight_sums;
      offset_coords *= image_info.image_texel_size_on_master_index_tile;

      master_coords = corner_coords + offset_coords;
      t00 = fastuidraw_linear_filter_atlas_image(master_coords.xz, index_layer, image_info, lod);
      t10 = fastuidraw_linear_filter_atlas_image(master_coords.yz, index_layer, image_info, lod);
      t01 = fastuidraw_linear_filter_atlas_image(master_coords.xw, index_layer, image_info, lod);
      t11 = fastuidraw_linear_filter_atlas_image(master_coords.yw, index_layer, image_info, lod);
    }

  image_color = mix(mix(t00, t10, linear_weight.x),
                    mix(t01, t11, linear_weight.x),
                    linear_weight.y);

  return image_color;
}
