vec4
fastuidraw_gl_vert_main(in vec4 primary_attrib,
                       in vec4 secondary_attrib,
                       in uvec4 uint_attrib,
                       in uint shader_data_offset,
                       out uint z_add)
{
  vec2 p;
  vec2 position, normal, tangent, tn_offset, offset;
  float distance_from_edge_start, distance_from_outline_start;
  float miter_distance, stroking_on_boundary, stroke_radius;
  fastuidraw_stroking_params stroke_params;

  position = primary_attrib.xy;
  normal = primary_attrib.zw;
  tangent = vec2(normal.y, -normal.x);
  tn_offset = secondary_attrib.zw;
  distance_from_edge_start = secondary_attrib.x;
  distance_from_outline_start = secondary_attrib.y;


  fastuidraw_read_stroking_params(shader_data_offset, stroke_params);
  stroke_radius = 0.5 * stroke_params.width;

  /* if point type is miter point and if stroke_params.miter_limit >= 0.0
     then clamp tn_offset.x so that absolute value is no more than stroke_params.miter_limit
   */
  if(uint_attrib.y == uint(fastuidraw_stroke_miter_join_point) && stroke_params.miter_limit >= 0.0)
    {
      tn_offset.x = clamp(tn_offset.x, -stroke_params.miter_limit, stroke_params.miter_limit);
    }

  offset = tn_offset.x * tangent + tn_offset.y * normal;

  /* stroking_on_boundary varying declared in C++ code
   */
  stroking_on_boundary = float(uint_attrib.z) - 1.0;

  /* idea:
      For anti-aliased via coverage, we have two passes:
       pass 1: FASTUIDRAW_STROKE_OPAQUE_PASS which is to draw
               the solid parts (i.e. fully covered). Thus
               we draw slightly less in width
       pass 2: FASTUIDRAW_STROKE_AA_PASS which is to draw just
               the anti-aliasing fuzz. In this case we need
               to start drawing where the FASTUIDRAW_STROKE_OPAQUE_PASS
               stopped and extend to the end.

   */

  if(abs(stroking_on_boundary) > 0.5)
    {
      #ifdef FASTUIDRAW_STROKE_WIDTH_IN_PIXELS
        {
          vec3 clip_offset, clip_p;
          float sx, sy;

          /* TODO: We have some uglies when stroke radius in pixels means
                   that the stroke radius varies in local coordinates.

              - Rounded-joins, rounded-caps: We can get around this by using
                                             offset instead of normal

              - Square Caps: We first apply algorithm to tangent,
                             then move position by amount requested
                             and then use offset as normal * tn_offset.y
                             and width applied again with normal.

              - Miter Joins: Such PAIN. The miter points (the two that make
                             the tip which conincide under the miter limit)
                             are made so that they coincide under the assumption
                             that both have the exact same stroking radius applied.
           */
          clip_p = fastuidraw_item_matrix * vec3(position, 1.0);
          clip_offset = fastuidraw_item_matrix * vec3(normal, 0.0);
          stroke_radius = fastuidraw_compute_local_distance_from_pixel_distance(stroke_radius, clip_p, clip_offset);
        }
      #endif

      #if defined(FASTUIDRAW_STROKE_OPAQUE_PASS)
        {
          vec2 q, sQ, sP, sR, sV, sD;
          vec3 P, Q;
          float clip_t, screen_t, recQz, recPz;

          q = position + stroke_radius * offset;
          P = fastuidraw_item_matrix * vec3(position, 1.0);
          Q = fastuidraw_item_matrix * vec3(q, 1.0);

          recPz = 1.0 / P.z;
          recQz = 1.0 / Q.z;
          sP = P.xy * recPz;
          sQ = Q.xy * recQz;
          sD = sQ - sP;
          sV = normalize(sD);

          /* We pull back the number of pixels given by anti_alias_thickness,
             that is the number of pixels we give to the anti-aliasing outline.
           */
          const float anti_alias_thickness = 1.0;
          /*
            normalized coordinates are -1 to 1, thus 1 pixel is
            given by (2.0 / number_pixels) in normalized coordinates
          */
          const float anti_alias_coeff = 2.0 * anti_alias_thickness;
          sR = sQ - (anti_alias_coeff * fastuidraw_viewport_recip_pixels_magnitude) * sV;

          /* screen_t is the screen space barycentric where sR is located
             between sP and sQ.
           */
          if(abs(sD.x) > abs(sD.y))
            {
              screen_t = (sR.x - sP.x) / sD.x;
            }
          else
            {
              screen_t = (sR.y - sP.y) / sD.y;
            }
          screen_t = clamp(screen_t, 0.0, 1.0);

          /* clip_t is the clip-space barycentric coordinate that projects to sR.
           */
          clip_t = (screen_t * recQz) / mix(recPz, recQz, screen_t);
          p = (1.0 - clip_t) * position + clip_t * q;
        }
      #else
        {
          p = position + stroke_radius * offset;
        }
      #endif
    }
  else
    {
      p = position;
    }

  #ifdef FASTUIDRAW_STROKE_AA_PASS
    {
      fastuidraw_stroking_on_boundary = stroking_on_boundary;
      z_add = 0u;
    }
  #else
    {
      z_add = uint_attrib.x;
    }
  #endif

  return vec4(p, p);
}
