vec4
fastuidraw_gl_vert_main(in vec4 primary_attrib,
                       in vec4 secondary_attrib,
                       in uvec4 uint_attrib,
                       in uint shader_data_offset,
                       out uint z_add)
{
  vec2 p;
  vec2 position, normal, tangent, tn_offset, offset;
  float distance_from_edge_start, distance_from_outline_start;
  float miter_distance, stroking_on_boundary;
  fastuidraw_stroking_params stroke_params;

  position = primary_attrib.xy;
  normal = primary_attrib.zw;
  tangent = vec2(normal.y, -normal.x);
  tn_offset = secondary_attrib.zw;
  distance_from_edge_start = secondary_attrib.x;
  distance_from_outline_start = secondary_attrib.y;


  fastuidraw_read_stroking_params(shader_data_offset, stroke_params);

  /* TODO:
      - if point type is miter point and if stroke_params.miter_limit >= 0.0
        then clamp tn_offset.x so that absolute value is no more than stroke_params.miter_limit
   */
  offset = tn_offset.x * tangent + tn_offset.y * normal;

  /* stroking_on_boundary varying declared in C++ code
   */
  stroking_on_boundary = float(uint_attrib.z) - 1.0;

  /* idea:
      For anti-aliased via coverage, we have two passes:
       pass 1: FASTUIDRAW_STROKE_OPAQUE_PASS which is to draw
               the solid parts (i.e. fully covered). Thus
               we draw slightly less in width
       pass 2: FASTUIDRAW_STROKE_AA_PASS which is to draw just
               the anti-aliasing fuzz. In this case we need
               to start drawing where the FASTUIDRAW_STROKE_OPAQUE_PASS
               stopped and extend to the end.

   */

  if(abs(stroking_on_boundary) > 0.5)
    {
      #ifdef FASTUIDRAW_STROKE_WIDTH_IN_PIXELS
        {
          vec3 clip_offset, clip_p;
          vec2 zeta;
          float stroke_width_normalized_dc;

          /* if stroking width is in pixels, then
             convert stroke_params.width so that
             after projection, we push off by that exact
             number of pixels.
          */
          clip_p = fastuidraw_item_matrix * vec3(position, 1.0);
          clip_offset = fastuidraw_item_matrix * vec3(offset, 0.0);
          zeta = vec2(clip_offset.x * clip_p.z - clip_offset.z * clip_p.x,
                      clip_offset.y * clip_p.z - clip_offset.z * clip_p.y);

          /* TODO:
              - We have render issues for rounded joins because the stroke
                width is not constant for the entire join, this happens
                when the viewport is not a square. Quite visible on rounded
                joins and rounded caps.

              - If offset is not of unit length, then there is distortion
                for those offset vectors. These offset values come up in
                * Miter joins: at the Miter point
                * Square caps: at the corners of the caps

             Possible fix idea:
              - For points on a join we have an additional attribute that
                goes from -1 to 1, where when it is -1 or 1 indicates a
                point shared from the usual stroking and value inbetween
                are points of the join. We take the absolute value of that
                parameter and then use that to mix() between isotropic
                and anisotropic correction below. This will fix rounded
                joins and caps.

              - For Miter point (miter_distance != 0.0), we do:
                  -- first walk by pre_offset as needed
                  -- second walk by factor * perp as needed

              - For Square points, we would first walk perpindicular
                then tangentially, but we need a way to recognize that
                we are using such points (tag them?)
           */
          stroke_width_normalized_dc = 0.5 * stroke_params.width;
          if(abs(clip_offset.x) > abs(clip_offset.y))
            {
              stroke_width_normalized_dc *= fastuidraw_viewport_recip_pixels.x;
            }
          else
            {
              stroke_width_normalized_dc *= fastuidraw_viewport_recip_pixels.y;
            }

          /* From where this formula comes. Our challenge is to give a stroking width
             in local (pre-projection) coordiantes from a stroking width of pixels.
             We have a point p (given by position) and a direction v (given by offset)
             and we wish to find an L so that after projection p + L*v is W pixels
             from p. Now for some math.

             Let m>0, and let q(m) = a + m*v. Once m>0 is large enough, we can
             project q(m) and p to the screen, find the screen space barycentric
             W pixels from p.

             Let P = projection(T(p,1))
             Let Q(m) = projection(T(q(m),1))

             where

             T = fastuidraw_item_matrix
             projection(x,y,z) = (x/z, y/z)

             Let R = P + W * DELTA where DELTA = (Q(m) - P)/||Q(m)-P||
             Let s = W / ||Q(m) - P|| gives that P + s * (Q(m) - P) = R.
             Let t = ( s/Q(m)_z ) / ( (1-s)/P_z + s/Q(m)_z). Then
             projection( T(p,1) + t * (T(q(m),1) - T(p,1)) ) = R

                  t * (T(q(m),1) - T(p,1)) = t * (T(p,1) + m*T(v,0) - T(p,1)) = t * m * T(v, 0)

             Thus the coefficient we want is given by (t*m).

             t * m = ( m * s * P_z) / ( (1-s)Q(m)_z + s * P_z)

             which simplifies to (after lots of algedra) to

             t * m = (W * P_z * P_z) / (W * T(v,0)_z + ||zeta||)

             where zeta = (T(v,0)_x * T(p,1)_z - T(v,0)_z * T(p,1)_x,
                           T(v,0)_y * T(p,1)_z - T(v,0)_z * T(p,1)_y)
          */
          stroke_params.width = stroke_width_normalized_dc * clip_p.z * clip_p.z;
          stroke_params.width /= (stroke_width_normalized_dc * clip_p.z * clip_offset.z + length(zeta));
        }
      #endif

      #if defined(FASTUIDRAW_STROKE_OPAQUE_PASS)
        {
          vec2 q, sQ, sP, sR, sV, sD;
          vec3 P, Q;
          float clip_t, screen_t, recQz, recPz;

          q = position + (0.5 * stroke_params.width) * offset;
          P = fastuidraw_item_matrix * vec3(position, 1.0);
          Q = fastuidraw_item_matrix * vec3(q, 1.0);

          recPz = 1.0 / P.z;
          recQz = 1.0 / Q.z;
          sP = P.xy * recPz;
          sQ = Q.xy * recQz;
          sD = sQ - sP;
          sV = normalize(sD);

          /* We pull back the number of pixels given by anti_alias_thickness,
             that is the number of pixels we give to the anti-aliasing outline.
           */
          const float anti_alias_thickness = 1.0;
          /*
            normalized coordinates are -1 to 1, thus 1 pixel is
            given by (2.0 / number_pixels) in normalized coordinates
          */
          const float anti_alias_coeff = 2.0 * anti_alias_thickness;
          sR = sQ - (anti_alias_coeff * fastuidraw_viewport_recip_pixels_magnitude) * sV;

          /* screen_t is the screen space barycentric where sR is located
             between sP and sQ.
           */
          if(abs(sD.x) > abs(sD.y))
            {
              screen_t = (sR.x - sP.x) / sD.x;
            }
          else
            {
              screen_t = (sR.y - sP.y) / sD.y;
            }
          screen_t = clamp(screen_t, 0.0, 1.0);

          /* clip_t is the clip-space barycentric coordinate that projects to sR.
           */
          clip_t = (screen_t * recQz) / mix(recPz, recQz, screen_t);
          p = (1.0 - clip_t) * position + clip_t * q;
        }
      #else
        {
          p = position + (0.5 * stroke_params.width) * offset;
        }
      #endif
    }
  else
    {
      p = position;
    }

  #ifdef FASTUIDRAW_STROKE_AA_PASS
    {
      fastuidraw_stroking_on_boundary = stroking_on_boundary;
      z_add = 0u;
    }
  #else
    {
      z_add = uint_attrib.x;
    }
  #endif

  return vec4(p, p);
}
