#ifndef FASTUIDRAW_PAINTER_STROKE_VERT
#define FASTUIDRAW_PAINTER_STROKE_VERT

void
fastuidraw_stroke_vert_align_compute_Q_adjoint_Q(in vec3 pclip_p,
                                                 out mat2 Q, out mat2 adjQ)
{
  vec3 clip;
  clip = vec3(fastuidraw_viewport_pixels, 1.0) * pclip_p;

  vec2 c0, c1;
  c0.x = clip.z * fastuidraw_item_matrix[0].x - clip.x * fastuidraw_item_matrix[0].z;
  c0.y = clip.z * fastuidraw_item_matrix[0].y - clip.y * fastuidraw_item_matrix[0].z;
  c1.x = clip.z * fastuidraw_item_matrix[1].x - clip.x * fastuidraw_item_matrix[1].z;
  c1.y = clip.z * fastuidraw_item_matrix[1].y - clip.y * fastuidraw_item_matrix[1].z;

  Q = mat2(c0, c1);
  adjQ = mat2( Q[1][1], -Q[0][1], -Q[1][0], Q[0][0]);
}

vec2
fastuidraw_stroke_vert_align_normal_to_screen(in vec3 clip_p, in vec2 n)
{
  mat2 Q, adjQ;

  fastuidraw_stroke_vert_align_compute_Q_adjoint_Q(clip_p, Q, adjQ);

  vec2 n_screen, t_screen, t;

  t = vec2(-n.y, n.x);
  t_screen = fastuidraw_viewport_pixels * (Q * t);
  n_screen = vec2(t_screen.y, -t_screen.x);

  /* NOTE!
       We do NOT divide by the det of Q, this is because
       we only care about the -direction- of return
       value, not the magnitude, thus the adjoint is
       good enough [and it avoids us needing to deal
       with a the case if the determinant is 0].
   */
  return adjQ * (fastuidraw_viewport_recip_pixels * n_screen);
}

#endif

vec4
fastuidraw_gl_vert_main(in vec4 primary_attrib,
                       in vec4 secondary_attrib,
                       in uvec4 uint_attrib,
                       in uint shader_data_offset,
                       out uint z_add)
{
  vec2 p;
  vec2 position, pre_offset, auxilary_offset, offset;
  float distance_from_edge_start, distance_from_outline_start;
  float miter_distance, stroking_on_boundary, stroke_radius;
  fastuidraw_stroking_params stroke_params;
  int on_boundary;

  position = primary_attrib.xy;
  pre_offset = primary_attrib.zw;
  auxilary_offset = secondary_attrib.zw;
  distance_from_edge_start = secondary_attrib.x;
  distance_from_outline_start = secondary_attrib.y;


  fastuidraw_read_stroking_params(shader_data_offset, stroke_params);
  stroke_radius = 0.5 * stroke_params.width;

  /* stroking_on_boundary varying declared in C++ code
   */
  on_boundary = int(uint_attrib.z) - 1;

  /* Depending on the point type, we have a different way to produce offset
   */
  switch(int(uint_attrib.y & uint(fastuidraw_stroke_point_type_mask)))
    {
    case fastuidraw_stroke_miter_join_point:
      {
        #ifdef FASTUIDRAW_STROKE_WIDTH_IN_PIXELS
          {
            vec2 n0 = pre_offset, v0 = vec2(n0.y, -n0.x);
            vec2 n1 = auxilary_offset, v1 = vec2(n1.y, -n1.x);
            vec2 p0, p1, delta_p;
            vec3 clip_p, clip_offset;
            float det, r, r0, r1, m, lambda;

            lambda = -sign(dot(v1, n0));
            clip_p = fastuidraw_item_matrix * vec3(position, 1.0);

            n0 = lambda * fastuidraw_stroke_vert_align_normal_to_screen(clip_p, n0);
            n1 = lambda * fastuidraw_stroke_vert_align_normal_to_screen(clip_p, n1);

            /* let p0 be p moved by n0 the named number of pixels.
             */
            clip_offset = fastuidraw_item_matrix * vec3(n0, 0.0);
            r0 = fastuidraw_compute_local_distance_from_pixel_distance(stroke_radius, clip_p, clip_offset);
            p0 = position + r0 * n0;

            /* let p1 be p moved by n1 the named number of pixels.
             */
            clip_offset = fastuidraw_item_matrix * vec3(n1, 0.0);
            r1 = fastuidraw_compute_local_distance_from_pixel_distance(stroke_radius, clip_p, clip_offset);
            p1 = position + r1 * n1;

            /* now compute where the lines L0 and L1 intersect
               where L0 = { p0 + s*v0 | s > 0}
               and L1 = { p1 - s*v1 | s > 0}
             */
            delta_p = p1 - p0;
            det = v0.x * v1.y - v0.y * v1.x;

            if(det != 0.0)
              {
                m = (v1.y * delta_p.x - v1.x * delta_p.y) / det;
              }
            else
              {
                m = 0.0;
              }

            /* miter limit; we have an itchy situation in that
               we have two different stroke radii, r0 and r1.
               we will take their maximum as the stroke radius
               for enforcing the miter limit.
             */
            if(stroke_params.miter_limit >= 0.0)
              {
                r = max(r0, r1) * stroke_params.miter_limit;
                m = clamp(m, -r, r);
              }

            offset = p0 + m * v0 - position;
            stroke_radius = 1.0;
          }
        #else
          {
            vec2 n = pre_offset, v = vec2(-n.y, n.x);
            float r, numer, denom, lambda;
            lambda = -sign(dot(v, auxilary_offset));
            numer = dot(pre_offset, auxilary_offset) - 1.0;
            denom = dot(v, auxilary_offset);
            r = (denom != 0.0) ? numer/denom : 0.0;

            /* enforce miter-limit
             */
            if(stroke_params.miter_limit >= 0.0)
              {
                r = clamp(r, -stroke_params.miter_limit, stroke_params.miter_limit);
              }
            offset = lambda * (n - r * v);
          }
        #endif
      }
      break;

    case fastuidraw_stroke_square_cap_point:
      {
        #ifdef FASTUIDRAW_STROKE_WIDTH_IN_PIXELS
          {
            vec3 clip_offset0, clip_offset1, clip_p;
            float s0, s1;
            vec2 n;

            /* move along tangent named number of pixels
             */
            clip_p = fastuidraw_item_matrix * vec3(position, 1.0);
            clip_offset0 = fastuidraw_item_matrix * vec3(auxilary_offset, 0.0);
            s0 = fastuidraw_compute_local_distance_from_pixel_distance(stroke_radius, clip_p, clip_offset0);

            /* move along normal named number of pixels
             */
            clip_p = fastuidraw_item_matrix * vec3(position + s0 * auxilary_offset, 1.0);
            n = fastuidraw_stroke_vert_align_normal_to_screen(clip_p, pre_offset);
            clip_offset1 = fastuidraw_item_matrix * vec3(n, 0.0);
            s1 = fastuidraw_compute_local_distance_from_pixel_distance(stroke_radius, clip_p, clip_offset1);

            stroke_radius = 1.0;
            offset = s0 * auxilary_offset + s1 * n;
          }
        #else
          {
            offset = pre_offset + auxilary_offset;
          }
        #endif
      }
      break;

    case fastuidraw_stroke_rounded_join_point:
      {
        vec2 n0, n1;
        float interpolate;

        n0 = fastuidraw_unpack_unit_vector(pre_offset.x, uint(fastuidraw_stroke_normal0_y_sign_mask) & uint_attrib.y);
        n1 = fastuidraw_unpack_unit_vector(pre_offset.y, uint(fastuidraw_stroke_normal1_y_sign_mask) & uint_attrib.y);
        interpolate = auxilary_offset.x;
        #ifdef FASTUIDRAW_STROKE_WIDTH_IN_PIXELS
          {
            vec3 clip_p, clip_offset;
            vec2 t0, t1, screen_t0, screen_t1, screen_t, screen_n;
            mat2 Q, adjQ;
	    float d;

            clip_p = fastuidraw_item_matrix * vec3(position, 1.0);
            fastuidraw_stroke_vert_align_compute_Q_adjoint_Q(clip_p, Q, adjQ);

            t0 = vec2(-n0.y, n0.x);
            t1 = vec2(-n1.y, n1.x);
	    screen_t0 = normalize(fastuidraw_viewport_pixels * (Q * t0));
	    screen_t1 = normalize(fastuidraw_viewport_pixels * (Q * t1));
	    d = dot(screen_t0, screen_t1);

	    if(d > 0.0)
	      {
		screen_t = mix(screen_t0, screen_t1, interpolate);
	      }
	    else
	      {
		/* "Joy", screen_t0 and screen_t1 point in different
		   directions. In this painful case we will interpolate
		   along a circle
		 */
		screen_t = fastuidraw_circular_interpolate(screen_t0, screen_t1, d, interpolate);
	      }
	    screen_n = vec2(screen_t.y, -screen_t.x);

            offset = adjQ * (fastuidraw_viewport_recip_pixels * screen_n);
            clip_offset = fastuidraw_item_matrix * vec3(offset, 0.0);
            stroke_radius = fastuidraw_compute_local_distance_from_pixel_distance(stroke_radius, clip_p, clip_offset);
          }
        #else
          {
            vec2 n;
            n = mix(n0, n1, interpolate);
            offset = normalize(n);
          }
        #endif
      }
      break;

    case fastuidraw_stroke_rounded_cap_point:
      {
        /* Up to sign, normal is the same on both sides, we use the normal
           vector to determine the radius of the cap. The (cos, sin) data
           for the cap is packed in auxilary_offset and the normal is
           in pre_offset.
         */
        vec2 n = pre_offset, v = vec2(n.y, -n.x);
        #ifdef FASTUIDRAW_STROKE_WIDTH_IN_PIXELS
          {
            vec3 clip_n, clip_v, clip_p;
            vec2 tn = auxilary_offset;

            clip_p = fastuidraw_item_matrix * vec3(position, 1.0);
            n = fastuidraw_stroke_vert_align_normal_to_screen(clip_p, n);

            clip_v = fastuidraw_item_matrix * vec3(v, 0.0);
            tn.x = fastuidraw_compute_local_distance_from_pixel_distance(tn.x * stroke_radius, clip_p, clip_v);

            clip_n = fastuidraw_item_matrix * vec3(n, 0.0);
            tn.y = fastuidraw_compute_local_distance_from_pixel_distance(tn.y * stroke_radius, clip_p, clip_n);

            stroke_radius = 1.0;
            offset = tn.x * v + tn.y * n;
          }
        #else
          {
            offset = auxilary_offset.x * v + auxilary_offset.y * pre_offset;
          }
        #endif
      }
      break;

    default:
      {
        #ifdef FASTUIDRAW_STROKE_WIDTH_IN_PIXELS
          {
            if(on_boundary != 0)
              {
                vec3 clip_offset, clip_p;
                vec2 n;
                if(on_boundary == 1)
                  {
                    clip_p = fastuidraw_item_matrix * vec3(position, 1.0);
                  }
                else
                  {
                    clip_p = fastuidraw_item_matrix * vec3(position + auxilary_offset, 1.0);
                  }
                n = fastuidraw_stroke_vert_align_normal_to_screen(clip_p, pre_offset);
                clip_offset = fastuidraw_item_matrix * vec3(n, 0.0);
                stroke_radius = fastuidraw_compute_local_distance_from_pixel_distance(stroke_radius, clip_p, clip_offset);
                offset = n;
              }
          }
        #else
          {
            if(on_boundary != 0)
              {
                offset = pre_offset;
              }
            else
              {
                offset = vec2(0.0, 0.0);
              }
          }
        #endif
      }
    }

  /* idea:
      For anti-aliased via coverage, we have two passes:
       pass 1: FASTUIDRAW_STROKE_OPAQUE_PASS which is to draw
               the solid parts (i.e. fully covered). Thus
               we draw slightly less in width
       pass 2: FASTUIDRAW_STROKE_AA_PASS which is to draw just
               the anti-aliasing fuzz. In this case we need
               to start drawing where the FASTUIDRAW_STROKE_OPAQUE_PASS
               stopped and extend to the end.

   */

  if(on_boundary != 0)
    {
      #if defined(FASTUIDRAW_STROKE_OPAQUE_PASS)
        {
          vec2 q, sQ, sP, sR, sV, sD;
          vec3 P, Q;
          float clip_t, screen_t, recQz, recPz;

          q = position + stroke_radius * offset;
          P = fastuidraw_item_matrix * vec3(position, 1.0);
          Q = fastuidraw_item_matrix * vec3(q, 1.0);

          recPz = 1.0 / P.z;
          recQz = 1.0 / Q.z;
          sP = P.xy * recPz;
          sQ = Q.xy * recQz;
          sD = sQ - sP;
          sV = normalize(sD);

          /* We pull back the number of pixels given by anti_alias_thickness,
             that is the number of pixels we give to the anti-aliasing outline.
           */
          const float anti_alias_thickness = 1.0;
          /*
            normalized coordinates are -1 to 1, thus 1 pixel is
            given by (2.0 / number_pixels) in normalized coordinates
          */
          const float anti_alias_coeff = 2.0 * anti_alias_thickness;
          sR = sQ - (anti_alias_coeff * fastuidraw_viewport_recip_pixels_magnitude) * sV;

          /* screen_t is the screen space barycentric where sR is located
             between sP and sQ.
           */
          if(abs(sD.x) > abs(sD.y))
            {
              screen_t = (sR.x - sP.x) / sD.x;
            }
          else
            {
              screen_t = (sR.y - sP.y) / sD.y;
            }
          screen_t = clamp(screen_t, 0.0, 1.0);

          /* clip_t is the clip-space barycentric coordinate that projects to sR.
           */
          clip_t = (screen_t * recQz) / mix(recPz, recQz, screen_t);
          p = (1.0 - clip_t) * position + clip_t * q;
        }
      #else
        {
          p = position + stroke_radius * offset;
        }
      #endif
    }
  else
    {
      p = position;
    }

  #ifdef FASTUIDRAW_STROKE_AA_PASS
    {
      fastuidraw_stroking_on_boundary = float(abs(on_boundary));
      z_add = 0u;
    }
  #else
    {
      z_add = uint_attrib.x;
    }
  #endif

  return vec4(p, p);
}
